"""
The response recieved when an app is installed or the permissions are updated
"""
type AppInstallationResponse {
  demandHqIdentities: [DemandHqIdentity]!
}

"""What stage and availability the app is in"""
enum AppStatus {
  """The app is in the process of being created"""
  DRAFT

  """The app is available to install, but only through shared links"""
  PRIVATE

  """The app is available to install, and is searchable/discoverable"""
  PUBLIC
}

"""
This is the primary determination of which permission scopes can be requested.
An app cannot be more than one of these.
If something cross domain needs to exist, it should be two apps and they can communicate.
"""
enum AppType {
  DEMANDHQAPP
  STOREFRONTAPP
  SUPPLIERAPP
}

"""
A Collection is a group of products, what may often be referred to as a "Category Page" of some variety.
In reality, a collection is far more flexible and can be used to represent any
product grouping, and the collectionType can help differentiate between them.
"""
type Collection {
  collectionId: ID!

  """
  Any string to declare a category of this collection, can be used to filter collections, limit 128 characters.
  """
  collectionType: String!

  """Get the content of the collection."""
  content: CollectionContent

  """
  The ContentItemIds of the Content Items that are associated with this collection.
  """
  contentItemIds: [ID!]

  """Get the content items of the collection."""
  contentItems: [CollectionContentItem]
  createdAt: Date!
  demandHqId: ID!

  """A short description of the collection, limit 1000 characters."""
  description: String

  """
  This can be used to pin certain products to the top of a collection when using certain sorts.
  Max number of products is 20.
  """
  featuredProductIds: [ID]

  """
  A primary image url for this collection, can be generated from a Collection ContentItem.
  """
  primaryImageUrl: String

  """
  Paginate through products in a collection.
  
  Requires the product/read scope.
  """
  products(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Optionally filter by manufacturer."""
    manufacturer: [StringFilterInput]

    """Optionally filter by msrp."""
    msrp: [FloatRangeFilterInput]

    """Optionally filter by price."""
    price: [FloatRangeFilterInput]

    """Filter Products to a set of productIds"""
    productIds: [ID]

    """
    Query products for certain terms. Searches several fields, including
    product.tags, product.title, product.vendor, productLocales.description,
    productLocales.featureBullets, variant.barcode, variant.mpn, variant.sku
    """
    query: String

    """Filter Products to a set of slugs"""
    slugs: [String]

    """
    Sort Products by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [ProductSortInput]

    """Optionally filter by standardized color."""
    standardizedColor: [ProductStandardizedColorFilterInput]

    """Filter Products using Status."""
    status: ProductStatusFilterInput

    """Optionally filter by storefrontIds."""
    storefrontIds: IDFilterInput

    """Optionally filter by tags."""
    tags: [StringFilterInput]

    """Optionally filter by vendor."""
    vendor: StringFilterInput
  ): ProductConnectionWithSearch!

  """
  ISO format date when the collection was published. Note that ensuing updates
  with status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """
  A map of rules to determine whether a Product should be part of this Collection.
  """
  rules: CollectionRules

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this collection. Limit 128 characters."""
  slug: String!

  """The status of the collection, can be DRAFT or PUBLISHED."""
  status: CollectionStatus!

  """Which storefronts should have access to this collection?"""
  storefrontIds: [ID]

  """The subtitle of the collection, limit 256 characters."""
  subtitle: String

  """Get the tags of the collection."""
  tags: CollectionTags

  """The title of the collection, limit 256 characters."""
  title: String!
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through Collections"""
type CollectionConnectionWithSearch {
  edges: [CollectionEdge]!
  nodes: [Collection]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""This is the actual markdown content for the collection"""
type CollectionContent {
  collectionId: ID!

  """Get the markdown content of the collection as parsed HTML."""
  contentAsHtml: String
  contentAsString: String!
  demandHqId: ID!

  """Get the secondary markdown content of the collection as parsed HTML."""
  secondaryContentAsHtml: String
  secondaryContentAsString: String
  updatedAt: String
  updatedBy: ID!
}

"""
These are content items that are associated with a collection, Images, Videos, etc
"""
type CollectionContentItem {
  contentExtension: String!
  contentItemId: ID!
  contentKey: String!
  contentType: String!
  demandHqId: ID!
}

"""Upsert collection content for an existing Collection"""
input CollectionContentUpsertInput {
  collectionId: ID!
  contentAsString: String!
  secondaryContentAsString: String
}

"""
Exactly like Collection, but no publishedAt or Status (Status is set to DRAFT on create).
"""
input CollectionCreateInput {
  """
  Any string to declare a category of this collection, can be used to filter collections, limit 128 characters.
  """
  collectionType: String!

  """
  The ContentItemIds of the Content Items that are associated with this collection.
  """
  contentItemIds: [ID!]
  demandHqId: ID!

  """A short description of the collection, limit 1000 characters."""
  description: String

  """
  A primary image url for this collection, can be generated from a Collection ContentItem.
  """
  primaryImageUrl: String

  """
  A map of rules to determine whether a Product should be part of this Collection.
  """
  rules: CollectionRulesInput

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this collection. Limit 128 characters."""
  slug: String!

  """Which storefronts should have access to this collection?"""
  storefrontIds: [ID]

  """The subtitle of the collection, limit 256 characters."""
  subtitle: String
  tags: [String]

  """The title of the collection, limit 256 characters."""
  title: String!
}

"""Returned object from deleteCollection"""
type CollectionDeleteResponse {
  deletedId: ID!
}

"""One edge producing one Collection Node"""
type CollectionEdge {
  node: Collection
}

"""
Input object for creating an Image for a Collection from a File on a device
"""
input CollectionImageFromFileInput {
  collectionId: ID!
  demandHqId: ID!
  fileExtension: String!
  fileName: String!
}

"""Returned object from createCollectionImageFromFile"""
type CollectionImageFromFileResponse {
  collection: Collection!

  """The contentItemId of the image"""
  contentItemId: ID!

  """Used while uploading the image"""
  fields: JSON!

  """Used to upload the image"""
  url: String!
}

"""Input object for creating an Image for a Collection from a URL"""
input CollectionImageFromUrlInput {
  collectionId: ID!
  demandHqId: ID!
  url: String!
}

"""A rule to determine whether a Product should be part of a Collection."""
type CollectionRule {
  """The field to match against"""
  field: CollectionRuleField!

  """The operator to use when matching"""
  operator: CollectionRuleOperator!

  """The value to match against"""
  value: String!
}

"""Indicates which field a CollectionRule applies to"""
enum CollectionRuleField {
  TAG
  VENDOR
}

"""Input object to set a rule for a Collection"""
input CollectionRuleInput {
  """The field to match against"""
  field: CollectionRuleField!

  """The operator to use when matching"""
  operator: CollectionRuleOperator!

  """The value to match against"""
  value: String!
}

"""
Indicates how the value of the CollectionRuleField should be matched to actual values.
Note that for "NOT" functionality, you should instead include the whole CollectionRule in the "not" array.
"""
enum CollectionRuleOperator {
  EQUALS
}

"""
The rules to determine whether a Product should be part of a Collection.
"""
type CollectionRules {
  """ALL of the rules for this array must match a given prospective Product"""
  all: [CollectionRule]

  """ANY of the rules for this array must match a given prospective Product"""
  any: [CollectionRule]

  """
  If rules in this array match, a prospective Product should be excluded from the Collection
  """
  not: [CollectionRule]
}

"""Input object to set rules for a Collection"""
input CollectionRulesInput {
  """ALL of the rules for this array must match a given prospective Product"""
  all: [CollectionRuleInput]

  """ANY of the rules for this array must match a given prospective Product"""
  any: [CollectionRuleInput]

  """
  If rules in this array match, a prospective Product should be excluded from the Collection
  """
  not: [CollectionRuleInput]
}

"""Indicates whether the user type is an app or human user"""
enum CollectionStatus {
  DRAFT
  PUBLISHED
}

"""These are the tags associated to the collection"""
type CollectionTags {
  collectionId: ID!
  demandHqId: ID!

  """Get parsed, and optionally filtered, tags for a Collection."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""
ID Fields are required, but all other fields are optional, only included fields will be updated.
"""
input CollectionUpdateInput {
  collectionId: ID!

  """
  Any string to declare a category of this collection, can be used to filter collections, limit 128 characters.
  """
  collectionType: String

  """
  The ContentItemIds of the Content Items that are associated with this collection.
  """
  contentItemIds: [ID!]

  """A short description of the collection, limit 1000 characters."""
  description: String

  """
  A primary image url for this collection, can be generated from a Collection ContentItem.
  """
  primaryImageUrl: String

  """
  ISO format date when the collection was published. Note that ensuing updates
  with status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """
  A map of rules to determine whether a Product should be part of this Collection.
  """
  rules: CollectionRulesInput

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this collection. Limit 128 characters."""
  slug: String

  """The status of the collection, can be DRAFT or PUBLISHED."""
  status: CollectionStatus

  """Which storefronts should have access to this collection?"""
  storefrontIds: [ID]

  """The subtitle of the collection, limit 256 characters."""
  subtitle: String
  tags: [String]

  """The title of the collection, limit 256 characters."""
  title: String
}

"""
A customer of a given Storefront is a user who places orders on the Storefront
"""
type Customer {
  createdAt: Date!

  """
  Get a CustomerAddress by their customerAddressId.
              
  Requires the customeraddress/read permission for the associated DemandHq.
  """
  customerAddress(customerAddressId: ID!): CustomerAddress

  """
  Get a list of CustomerAddresses.
  
  Requires the customeraddress/read permission for the associated DemandHq.
  """
  customerAddresses(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    customerAddressIds: [ID]

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): CustomerAddressConnection!
  customerId: ID!

  """
  Get the default billing address for a customer.
  
  Requires the customeraddress/read permission for the associated DemandHq.
  """
  defaultBillingAddress: CustomerAddress

  """
  The CustomerAddressId for the default billing address for this Customer
  """
  defaultBillingAddressId: ID

  """
  Get the default shipping address for a customer.
  
  Requires the customeraddress/read permission for the associated DemandHq.
  """
  defaultShippingAddress: CustomerAddress

  """
  The CustomerAddressId for the default shipping address for this Customer
  """
  defaultShippingAddressId: ID
  demandHqId: ID!

  """
  The email address associated with the Customer, must be unique to the storefront, limit 256 characters
  """
  emailAddress: String!
  emailMarketingConsent: CustomerMarketingConsent

  """
  Reference to the storefront's customer authentication system. Limit 256 characters.
  This field is required if this customer is going to access any authenticated data (like their orders).
  """
  externalCustomerId: ID

  """The first name of the Customer, limit 256 characters"""
  firstName: String

  """The last name of the Customer, limit 256 characters"""
  lastName: String

  """
  Must be unique to the Storefront. Limit 64 characters. Format +11231231234
  """
  phoneNumber: String
  smsMarketingConsent: CustomerMarketingConsent
  status: CustomerStatus!
  storefrontId: ID!

  """Get the tags of the customer."""
  tags: CustomerTags
  updatedAt: Date!
  updatedBy: ID!
}

"""
A customerAddress is an Address entity that is associated with a customer
"""
type CustomerAddress {
  """The city of the address"""
  city: String!

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String!
  createdAt: Date!
  customerAddressId: ID!
  customerId: ID!
  demandHqId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String!

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String!

  """The state of the address"""
  state: String!
  storefrontId: ID!

  """The first line of the street address"""
  streetAddress1: String!

  """The second line of the street address"""
  streetAddress2: String
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through CustomerAddresses"""
type CustomerAddressConnection {
  edges: [CustomerAddressEdge]!
  nodes: [CustomerAddress]!
  pageInfo: PageInfo!
}

"""Input for creating a CustomerAddress"""
input CustomerAddressCreateInput {
  """The city of the address"""
  city: String!

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String!
  customerId: ID!
  demandHqId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String!

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String!

  """The state of the address"""
  state: String!
  storefrontId: ID!

  """The first line of the street address"""
  streetAddress1: String!

  """The second line of the street address"""
  streetAddress2: String
}

"""One edge producing one CustomerAddress Node"""
type CustomerAddressEdge {
  node: CustomerAddress
}

"""Input for updating a CustomerAddress"""
input CustomerAddressUpdateInput {
  """The city of the address"""
  city: String

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String
  customerAddressId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String

  """The state of the address"""
  state: String

  """The first line of the street address"""
  streetAddress1: String

  """The second line of the street address"""
  streetAddress2: String
}

"""Paginate through Customers"""
type CustomerConnectionWithSearch {
  edges: [CustomerEdge]!
  nodes: [Customer]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""Input for creating a Customer"""
input CustomerCreateInput {
  """
  The CustomerAddressId for the default billing address for this Customer
  """
  defaultBillingAddressId: ID

  """
  The CustomerAddressId for the default shipping address for this Customer
  """
  defaultShippingAddressId: ID
  demandHqId: ID!

  """
  The email address associated with the Customer, must be unique to the storefront, limit 256 characters
  """
  emailAddress: String!
  emailMarketingConsent: CustomerMarketingConsentInput

  """
  Reference to the storefront's customer authentication system. Limit 256 characters.
  This field is required if this customer is going to access any authenticated data (like their orders).
  """
  externalCustomerId: ID

  """The first name of the Customer, limit 256 characters"""
  firstName: String

  """The last name of the Customer, limit 256 characters"""
  lastName: String

  """
  Must be unique to the Storefront. Limit 64 characters. Format +11231231234
  """
  phoneNumber: String
  smsMarketingConsent: CustomerMarketingConsentInput
  status: CustomerStatus!
  storefrontId: ID!
  tags: [String]
}

"""One edge producing one Customer Node"""
type CustomerEdge {
  node: Customer
}

"""Details about the Customer's marketing consent"""
type CustomerMarketingConsent {
  """The level at which the Customer has consented to marketing"""
  consentLevel: CustomerMarketingConsentLevel!

  """The date the associated Customer agreed to the marketing consent"""
  consentedAt: Date!
  hasConsented: Boolean!

  """Optional field to store where consent was sourced from"""
  source: String
}

"""Input for updating a Customer's marketing consent"""
input CustomerMarketingConsentInput {
  """The level at which the Customer has consented to marketing"""
  consentLevel: CustomerMarketingConsentLevel!

  """The date the associated Customer agreed to the marketing consent"""
  consentedAt: Date!
  hasConsented: Boolean!

  """Optional field to store where consent was sourced from"""
  source: String
}

"""The level at which the Customer has opted-in to Marketing."""
enum CustomerMarketingConsentLevel {
  """Level 3"""
  CONFIRMED_OPT_IN

  """Level 1"""
  SINGLE_OPT_IN

  """Level 2"""
  SINGLE_OPT_IN_WITH_NOTIFICATION
  UNKNOWN
}

"""The status of the associated Customer"""
enum CustomerStatus {
  """The associated Customer is active and able to login"""
  ACTIVE

  """The associated Customer is not active and unable to login"""
  DISABLED

  """The associated Customer is active, but has not yet setup a login"""
  GUEST
}

"""These are the tags associated to the Customer"""
type CustomerTags {
  customerId: ID!
  demandHqId: ID!

  """Get parsed, and optionally filtered, tags for a Customer."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""Input for updating a Customer"""
input CustomerUpdateInput {
  customerId: ID!

  """
  The CustomerAddressId for the default billing address for this Customer
  """
  defaultBillingAddressId: ID

  """
  The CustomerAddressId for the default shipping address for this Customer
  """
  defaultShippingAddressId: ID

  """
  The email address associated with the Customer, must be unique to the storefront, limit 256 characters
  """
  emailAddress: String
  emailMarketingConsent: CustomerMarketingConsentInput

  """
  Reference to the storefront's customer authentication system. Limit 256 characters.
  This field is required if this customer is going to access any authenticated data (like their orders).
  """
  externalCustomerId: ID

  """The first name of the Customer, limit 256 characters"""
  firstName: String

  """The last name of the Customer, limit 256 characters"""
  lastName: String

  """
  Must be unique to the Storefront. Limit 64 characters. Format +11231231234
  """
  phoneNumber: String
  smsMarketingConsent: CustomerMarketingConsentInput
  status: CustomerStatus
  tags: [String]
}

"""A date in ISO 8601 format"""
scalar Date

"""Returned object from deleteCollectionContentItem"""
type DeleteCollectionContentItemResponse {
  """The contentItemId of the contentItem that was deleted."""
  deletedId: ID!
}

"""Returned object from deleteCustomerAddress"""
type DeleteCustomerAddressResponse {
  """The customerAddressId of the customerAddress that was deleted."""
  deletedId: ID!
}

"""Returned object from deleteCustomer"""
type DeleteCustomerResponse {
  """The customerId of the customer that was deleted."""
  deletedId: ID!
}

"""The response from a delete request."""
type DeleteNavResponse {
  deletedId: ID!
}

"""Returned object from deletePageContentItem"""
type DeletePageContentItemResponse {
  """The contentItemId of the contentItem that was deleted."""
  deletedId: ID!
}

"""The parent-most entity of the DemandHq Domain"""
type DemandHq {
  """
  Get a collection by collectionId or slug (one must be provided).
              
  Required collection/read permission on the given DemandHq.
  """
  collection(collectionId: ID, slug: String): Collection!

  """
  List collections for a DemandHq with optional filters.
              
  Required collection/read permission on the given DemandHq.
  """
  collections(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Filter Collections to a set of collectionIds"""
    collectionIds: [ID]

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Filter Collections to a set of slugs"""
    slugs: [String]
  ): CollectionConnectionWithSearch!
  createdAt: String!
  defaultCurrency: ResonanceCurrency!
  defaultLocaleType: ResonanceLocaleType!
  demandHqId: ID!

  """
  Returns DemandHqIdentities for the given DemandHq
  
  Requires demandHqidentity/read permission on the requesting identity
  """
  demandHqIdentities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Filter the results to a specific identityParentEntityId (optional)"""
    identityParentEntityId: ID

    """Filter the results to a specific identity type (optional)"""
    identityType: DemandHqIdentityType

    """Returns the last n elements from the list."""
    last: Int
  ): DemandHqIdentityConnection!

  """
  Returns a DemandHqIdentity for the given DemandHq
  
  Requires demandHqidentity/read permission on the requesting identity, or you can request your own identity.
  """
  demandHqIdentity(demandHqId: ID!, identityId: ID!): DemandHqIdentity
  demandSubscriptionCodes: [DemandSubscriptionCode!]
  description: String
  name: String!

  """
  These users will get notified if something requires attention for this DemandHq.
  If none are provided, ownerUserName will be notified.
  """
  notificationUserNames: DemandHqNotificationUserNames
  ownerUserName: String!

  """
  Get a page by pageId or slug (one must be provided).
              
  Required page/read permission on the given DemandHq.
  """
  page(pageId: ID, slug: String): Page!

  """
  Term aggregations for Pages, typically used to suggest terms to use in Search Filters.
  """
  pageTermAggregations(
    """The number of aggregations to return for each type."""
    numberOfResults: Int!
  ): PageTermAggregations

  """
  List pages for a DemandHq with optional filters.
              
  Required page/read permission on the given DemandHq.
  """
  pages(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Filter Pages using author"""
    author: StringFilterInput

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Filter Pages to a set of pageIds"""
    pageIds: [ID]

    """Filter Pages using pageType"""
    pageType: StringFilterInput

    """
    Query pages for certain terms. Searches several fields, including
    page.author, page.description, page.subtitle, page.title, pageTags, and the
    actual content of the page.
    """
    query: String

    """Filter Pages to a set of slugs"""
    slugs: [String]

    """
    Sort Pages by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [PageSortInput]

    """Filter Pages using status"""
    status: PageStatusFilterInput

    """Optionally filter by storefrontIds."""
    storefrontIds: IDFilterInput

    """Filter Pages using Tags."""
    tags: [StringFilterInput]
  ): PageConnectionWithSearch!

  """
  Get a single product by ID or slug.
  
  Requires the product/read scope on the associated DemandHq.
  """
  product(productId: ID, slug: String): Product

  """
  Term aggregations for Products, typically used to suggest terms to use in Search Filters.
  """
  productTermAggregations(
    """The number of aggregations to return for each type."""
    numberOfResults: Int!
  ): ProductTermAggregations

  """
  Get a list of products.
  
  Requires the product/read scope on the associated DemandHq.
  """
  products(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Optionally filter by manufacturer."""
    manufacturer: [StringFilterInput]

    """Optionally filter by msrp."""
    msrp: [FloatRangeFilterInput]

    """Optionally filter by price."""
    price: [FloatRangeFilterInput]

    """Filter Products to a set of productIds"""
    productIds: [ID]

    """
    Query products for certain terms. Searches several fields, including
    product.tags, product.title, product.vendor, productLocales.description,
    productLocales.featureBullets, variant.barcode, variant.mpn, variant.sku
    """
    query: String

    """Filter Products to a set of slugs"""
    slugs: [String]

    """
    Sort Products by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [ProductSortInput]

    """Optionally filter by standardized color."""
    standardizedColor: [ProductStandardizedColorFilterInput]

    """Filter Products using Status."""
    status: ProductStatusFilterInput

    """Optionally filter by storefrontIds."""
    storefrontIds: IDFilterInput

    """Optionally filter by tags."""
    tags: [StringFilterInput]

    """Optionally filter by vendor."""
    vendor: StringFilterInput
  ): ProductConnectionWithSearch!
  status: DemandHqStatus!

  """
  Get a storefront by its storefrontId.
              
  Requires the storefront/read permission on the associated DemandHq.
  """
  storefront(storefrontId: ID!): Storefront

  """
  List storefronts for a DemandHq.
              
  Requires the storefront/read permission on the associated DemandHq.
  """
  storefronts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): StorefrontConnection
  updatedAt: String!
  updatedBy: ID!
}

"""The necessary fields in order to create a new demandHq"""
input DemandHqCreateInput {
  defaultCurrency: ResonanceCurrency!
  defaultLocaleType: ResonanceLocaleType!
  demandSubscriptionCodes: [DemandSubscriptionCode!]
  description: String
  name: String!

  """
  These users will get notified if something requires attention for this DemandHq.
  If none are provided, ownerUserName will be notified.
  """
  notificationUserNames: DemandHqNotificationUserNamesInput
}

"""Indicates a User or App has permissions on a DemandHq"""
type DemandHqIdentity {
  """Get the demandHq associated with this DemandHqIdentity."""
  demandHq: DemandHq
  demandHqId: ID!

  """Could be a userName or an appClientId"""
  identityId: ID!
  identityParentEntityId: ID
  identityType: DemandHqIdentityType!
  permissions: DemandHqIdentityPermissions!

  """Get a public identity for this DemandHqIdentity"""
  publicIdentity: PublicIdentity

  """Get the expanded PublicIdentityParent for this DemandHqIdentity"""
  publicIdentityParent: PublicIdentityParent
  updatedBy: String!
}

"""Paginate through DemandHqIdentities"""
type DemandHqIdentityConnection {
  edges: [DemandHqIdentityEdge]!
  nodes: [DemandHqIdentity]!
  pageInfo: PageInfo!
}

"""
Exactly like DemandHqIdentity, but no updatedBy or identityType (always User, Apps get installed)
"""
input DemandHqIdentityCreateInput {
  demandHqId: ID!

  """Always a user's userName (not appClientId)"""
  identityId: ID!
  identityParentEntityId: ID

  """Should always be USER"""
  identityType: DemandHqIdentityType!
  permissions: DemandHqIdentityPermissionsInput!
}

"""Returned object from deleteDemandHqIdentity"""
type DemandHqIdentityDeleteResponse {
  deletedId: DemandHqIdentityDeletedId
}

"""The deleted IDs identifying the DemandHqIdentity"""
type DemandHqIdentityDeletedId {
  demandHqId: ID!
  identityId: ID!
}

"""One edge producing one DemandHqIdentity Node"""
type DemandHqIdentityEdge {
  node: DemandHqIdentity
}

"""
Indicates which permissions this Identity possesses on a given DemandHq
"""
type DemandHqIdentityPermissions {
  roles: [String]!
  scopes: [String]!
}

"""Exactly like DemandHqIdentityPermissions"""
input DemandHqIdentityPermissionsInput {
  roles: [String]!
  scopes: [String]!
}

"""Indicates whether the user type is an app or human user"""
enum DemandHqIdentityType {
  APPCLIENT
  USER
}

"""
ID Fields are required, but all other fields are optional, only included fields will be updated.
"""
input DemandHqIdentityUpdateInput {
  demandHqId: ID!

  """Could be a userName or an appClientId"""
  identityId: ID!
  permissions: DemandHqIdentityPermissionsInput
}

"""
These users will get notified if something requires attention for this DemandHq.
If none are provided, ownerUserName will be notified.
"""
type DemandHqNotificationUserNames {
  """All notifications for the catalog side (Products, Variants, etc.)."""
  catalog: [String!]

  """All notifications for the commerce side, besides orders."""
  commerce: [String!]

  """
  These are part of commerce, but are a specific enough case to be handled separately.
  """
  orders: [String!]
}

"""Exactly like DemandHqNotificationUserNames"""
input DemandHqNotificationUserNamesInput {
  """All notifications for the catalog side (Products, Variants, etc.)."""
  catalog: [String!]

  """All notifications for the commerce side, besides orders."""
  commerce: [String!]

  """
  These are part of commerce, but are a specific enough case to be handled separately.
  """
  orders: [String!]
}

"""Indicates the status of a DemandHq"""
enum DemandHqStatus {
  ARCHIVED
  PUBLISHED
}

"""The possible fields in order to update a demandHq."""
input DemandHqUpdateInput {
  demandHqId: ID!
  demandSubscriptionCodes: [DemandSubscriptionCode!]
  description: String
  name: String

  """
  These users will get notified if something requires attention for this DemandHq.
  If none are provided, ownerUserName will be notified.
  """
  notificationUserNames: DemandHqNotificationUserNamesInput
  ownerUserName: String
}

"""Codes that signify a DemandSubscription"""
enum DemandSubscriptionCode {
  BETAMAX
}

"""Indicates how a filter should behave, defaults to OR"""
enum FilterOperator {
  AND
  NOT
  OR
}

"""
Filter using a min/max number range, in combination these function like an 'Any' filter.
"""
input FloatRangeFilterInput {
  max: Float!
  min: Float!
}

"""Filter using a combination of operator and an array of ID values"""
input IDFilterInput {
  operator: FilterOperator
  values: [ID!]!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""The root mutation type for the Demand domain"""
type Mutation {
  """
  Add a new Collection to a DemandHq.
  
  Requires the collection/write permission on the given DemandHq
  """
  createCollection(input: CollectionCreateInput!): Collection!

  """
  Create a Image for a Collection from a file.
  
  Requires the collection/write permission on the given DemandHq
  """
  createCollectionImageFromFile(input: CollectionImageFromFileInput!): CollectionImageFromFileResponse!

  """
  Create a Image for a Collection from a URL.
  
  Requires the collection/write permission on the given DemandHq
  """
  createCollectionImageFromUrl(input: CollectionImageFromUrlInput!): Collection!

  """
  Creates a new Customer
                  
  Requires the customer/write scope on the associated DemandHq.
  """
  createCustomer(input: CustomerCreateInput!): Customer

  """
  Creates a new CustomerAddress
                  
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  createCustomerAddress(input: CustomerAddressCreateInput!): CustomerAddress

  """
  Create a new demandHq
              
  Requires demandHq/write permission on the requesting identity
  """
  createDemandHq(input: DemandHqCreateInput!): DemandHq!

  """
  Add a new DemandHqIdentity to a DemandHq (give a user permissions)
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  createDemandHqIdentity(input: DemandHqIdentityCreateInput!): DemandHqIdentity!

  """
  Create a new Nav.
                  
  Requires the "nav/write" permission on the associated DemandHq.
  """
  createNav(input: NavCreateInput!): Nav

  """
  Add a new Page to a DemandHq.
  
  Requires the page/write permission on the given DemandHq
  """
  createPage(input: PageCreateInput!): Page!

  """
  Create a Image for a Page from a file.
  
  Requires the page/write permission on the given DemandHq
  """
  createPageImageFromFile(input: PageImageFromFileInput!): PageImageFromFileResponse!

  """
  Create a Image for a Page from a URL.
  
  Requires the page/write permission on the given DemandHq
  """
  createPageImageFromUrl(input: PageImageFromUrlInput!): Page!

  """
  Add a new Product to a DemandHq.
  
  Requires the product/write permission on the given DemandHq
  """
  createProduct(input: ProductCreateInput!): Product!

  """Create a new productLocale."""
  createProductLocale(input: ProductLocaleCreateInput!): ProductLocale!

  """
  Create a new Storefront.
      
  Requires the "storefront/write" scope on the associated DemandHq.
  """
  createStorefront(input: StorefrontCreateInput): Storefront

  """
  Create a new variant
              
  Requires variant/write permission on the associated demandHq for the requesting identity
  """
  createVariant(input: VariantCreateInput!): Variant!

  """
  Delete a Collection from a DemandHq.
  
  Requires the collection/write permission on the given DemandHq
  """
  deleteCollection(collectionId: ID!): CollectionDeleteResponse!

  """
  Delete a CollectionContentItem from a Collection.
  
  Requires the collection/write permission on the given DemandHq
  """
  deleteCollectionContentItem(collectionId: ID!, contentItemId: ID!): DeleteCollectionContentItemResponse!

  """
  Deletes a Customer
              
  Requires the customer/write scope on the associated DemandHq.
  """
  deleteCustomer(customerId: ID!): DeleteCustomerResponse!

  """
  Deletes a CustomerAddress
              
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  deleteCustomerAddress(customerAddressId: ID!): DeleteCustomerAddressResponse!

  """
  Delete a DemandHqIdentity from a DemandHq (remove a user's permissions)
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  deleteDemandHqIdentity(demandHqId: ID!, identityId: ID!): DemandHqIdentityDeleteResponse

  """
  Delete a Nav.
  
  Requires the "nav/write" permission on the associated DemandHq.
  """
  deleteNav(navId: ID!): DeleteNavResponse!

  """
  Delete a Page from a DemandHq.
  
  Requires the page/write permission on the given DemandHq
  """
  deletePage(pageId: ID!): PageDeleteResponse!

  """
  Delete a PageContentItem from a Page.
  
  Requires the page/write permission on the given DemandHq
  """
  deletePageContentItem(contentItemId: ID!, pageId: ID!): DeletePageContentItemResponse!

  """
  Delete a Product from a DemandHq.
  
  Requires the product/write permission on the given DemandHq
  """
  deleteProduct(productId: ID!): ProductDeleteResponse!

  """
  Delete a variant
              
  Requires variant/write permission on the associated demandHq for the requesting identity
  """
  deleteVariant(variantId: ID): VariantDeleteResponse!

  """
  Install an app to a DemandHq (give an app permissions)
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  installApp(appId: ID!, demandHqId: ID!): AppInstallationResponse!

  """
  Update an app's permissions on a DemandHq. This is a no-op if the app's
  requested permissions are the same as the current permissions.
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  updateAppPermissions(appId: ID!, demandHqId: ID!): AppInstallationResponse!

  """
  Update an existing collection.
  
  Requires the collection/write permission on the given DemandHq
  """
  updateCollection(input: CollectionUpdateInput!): Collection!

  """
  Updates an existing Customer
  
  Requires the customer/write scope on the associated DemandHq.
  """
  updateCustomer(input: CustomerUpdateInput!): Customer

  """
  Updates an existing CustomerAddress
  
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  updateCustomerAddress(input: CustomerAddressUpdateInput!): CustomerAddress

  """
  Update an existing demandHq
  
  Requires demandHq/write permission on the requesting identity
  """
  updateDemandHq(input: DemandHqUpdateInput!): DemandHq!

  """
  Update a DemandHqIdentity for a DemandHq (give a user permissions)
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  updateDemandHqIdentity(input: DemandHqIdentityUpdateInput!): DemandHqIdentity!

  """
  Update an existing Nav.
  
  Requires the "nav/write" permission on the associated DemandHq.
  """
  updateNav(input: NavUpdateInput!): Nav

  """
  Update an existing page.
  
  Requires the page/write permission on the given DemandHq
  """
  updatePage(input: PageUpdateInput!): Page!

  """
  Update an existing product.
  
  Requires the product/write permission on the given DemandHq
  """
  updateProduct(input: ProductUpdateInput!): Product!

  """Update an existing productLocale"""
  updateProductLocale(input: ProductLocaleUpdateInput!): ProductLocale!

  """
  Update an existing Storefront.
      
  Requires the "storefront/write" scope on the associated DemandHq.
  """
  updateStorefront(input: StorefrontUpdateInput): Storefront

  """
  Update an existing variant
              
  Requires variant/write permission on the associated demandHq for the requesting identity
  """
  updateVariant(input: VariantUpdateInput!): Variant!

  """
  Bulk update variants
  
  Requires variant/write permission on the associated demandHq for the requesting identity
  Note that if there are Permission or UserInput Errors, the entire group will fail, not partially succeed.
  """
  updateVariants(inputs: [VariantUpdateInput!]): [Variant!]

  """
  Add or Update CollectionContent for an existing Collection.
  
  Requires the collection/write permission on the given DemandHq
  """
  upsertCollectionContent(input: CollectionContentUpsertInput!): CollectionContent!

  """
  Add or Update PageContent for an existing Page.
  
  Requires the page/write permission on the given DemandHq
  """
  upsertPageContent(input: PageContentUpsertInput!): PageContent!

  """
  Upsert storefront nav settings.
                  
  Requires the storefrontnavsettings/write permission on the associated DemandHq.
  """
  upsertStorefrontNavSettings(input: StorefrontNavSettingsUpsertInput!): StorefrontNavSettings!
}

"""
Nav is an item within a navigational heirarchy of some kind, most often viewed as a menu.
"""
type Nav {
  createdAt: Date!
  demandHqId: ID!

  """
  Where this Nav link should lead to. Can be an absolute or relative url. 768 character limit.
  """
  href: String!

  """The label for this Nav, limit 64 characters."""
  label: String!

  """
  This has two primary purposes:
  To make this Nav "lookupable" in combination with linkType.
  To make entities aware they are being referenced. This is done with the
  reserved system linkTypes in combination with entitySlugs (i.e. Collection and
  a collection slug).
  """
  linkSlug: String!

  """
  This can be any string, but certain values have special meaning (like "collection").
  These are restricted to the specified values in NavSettings.
  """
  linkType: String!
  navId: ID!

  """
  A number, representing where this Nav resides in the heirarchy. Immutable, and
  limited to 0 through 6. 0 is the top level, 1 is the second level, etc.
  """
  navLevel: Int!

  """
  A string indicating the purpose of this Nav hierarchy, must match parentNav if applicable. Limit 128 characters.
  """
  navType: String!

  """
  List Child Navs for a nav.
  
  Requires the user to have the nav/read permission on the associated DemandHq.
  """
  navs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): NavConnection!

  """All Navs besides the root (Level 0) have a parentNavId. Immutable."""
  parentNavId: ID

  """
  Where this Nav should be located with respect to other Navs. Need not be sequential or unique.
  """
  position: Int
  storefrontId: ID!
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through Navs"""
type NavConnection {
  edges: [NavEdge]!
  nodes: [Nav]!
  pageInfo: PageInfo!
}

"""The input for creating a Nav."""
input NavCreateInput {
  demandHqId: ID!

  """
  Where this Nav link should lead to. Can be an absolute or relative url. 768 character limit.
  """
  href: String!

  """The label for this Nav, limit 64 characters."""
  label: String!

  """
  This has two primary purposes:
  To make this Nav "lookupable" in combination with linkType.
  To make entities aware they are being referenced. This is done with the
  reserved system linkTypes in combination with entitySlugs (i.e. Collection and
  a collection slug).
  """
  linkSlug: String!

  """
  This can be any string, but certain values have special meaning (like "collection").
  These are restricted to the specified values in NavSettings.
  """
  linkType: String!

  """
  A number, representing where this Nav resides in the heirarchy. Immutable, and
  limited to 0 through 6. 0 is the top level, 1 is the second level, etc.
  """
  navLevel: Int!

  """
  A string indicating the purpose of this Nav hierarchy, must match parentNav if applicable. Limit 128 characters.
  """
  navType: String!

  """All Navs besides the root (Level 0) have a parentNavId. Immutable."""
  parentNavId: ID

  """
  Where this Nav should be located with respect to other Navs. Need not be sequential or unique.
  """
  position: Int
  storefrontId: ID!
}

"""One edge producing one Nav Node"""
type NavEdge {
  node: Nav
}

"""The input for updating a Nav."""
input NavUpdateInput {
  """
  Where this Nav link should lead to. Can be an absolute or relative url. 768 character limit.
  """
  href: String

  """The label for this Nav, limit 64 characters."""
  label: String

  """
  This has two primary purposes:
  To make this Nav "lookupable" in combination with linkType.
  To make entities aware they are being referenced. This is done with the
  reserved system linkTypes in combination with entitySlugs (i.e. Collection and
  a collection slug).
  """
  linkSlug: String

  """
  This can be any string, but certain values have special meaning (like "collection").
  These are restricted to the specified values in NavSettings.
  """
  linkType: String
  navId: ID!

  """
  Where this Nav should be located with respect to other Navs. Need not be sequential or unique.
  """
  position: Int
}

"""
A Page is a part of the Demand Domain and represents a page with textual and
image content on it, that has nothing to do with products.
This can range from "About Us" pages to Blog articles. Use the "pageType" field to differentiate.
Pages do not have locales specified, but since everything would be different
anyway, "pageType" can be a composite key with locale in it.
"""
type Page {
  """The author of the page, limit 256 characters."""
  author: String

  """Get the content of the page."""
  content: PageContent

  """
  The ContentItemIds of the Content Items that are associated with this page.
  """
  contentItemIds: [ID!]

  """Get the content items of the page."""
  contentItems: [PageContentItem]
  createdAt: Date!
  demandHqId: ID!

  """A short description of the page, limit 1000 characters."""
  description: String

  """
  Get the description if it exists, or fallback to the excerpt of content for the page.
  """
  descriptionOrExcerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String
  pageId: ID!

  """
  Any string to declare a category of this page, can be used to filter pages, limit 128 characters.
  """
  pageType: String!

  """
  A primary image url for this page, can be generated from a Page ContentItem.
  """
  primaryImageUrl: String

  """
  ISO format date when the page was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this page. Limit 128 characters."""
  slug: String!

  """The status of the page, can be DRAFT or PUBLISHED."""
  status: PageStatus!

  """Which storefronts should have access to this page?"""
  storefrontIds: [ID]

  """The subtitle of the page, limit 256 characters."""
  subtitle: String

  """Get the tags of the page."""
  tags: PageTags

  """The title of the page, limit 256 characters."""
  title: String!
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through Pages"""
type PageConnectionWithSearch {
  edges: [PageEdge]!
  nodes: [Page]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""This is the actual content of the page"""
type PageContent {
  """Get the markdown content of the page as parsed HTML."""
  contentAsHtml: String
  contentAsString: String!
  demandHqId: ID!

  """Get an excerpt of the page content."""
  excerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String
  pageId: ID!
  updatedAt: String
  updatedBy: ID!
}

"""
These are content items that are associated with a page, Images, Videos, etc
"""
type PageContentItem {
  contentExtension: String!
  contentItemId: ID!
  contentKey: String!
  contentType: String!
  demandHqId: ID!
}

"""Upsert page content for an existing Page"""
input PageContentUpsertInput {
  contentAsString: String!
  pageId: ID!
}

"""
Exactly like Page, but no publishedAt or Status (Status is set to DRAFT on create).
"""
input PageCreateInput {
  """The author of the page, limit 256 characters."""
  author: String

  """
  The ContentItemIds of the Content Items that are associated with this page.
  """
  contentItemIds: [ID!]
  demandHqId: ID!

  """A short description of the page, limit 1000 characters."""
  description: String

  """
  Any string to declare a category of this page, can be used to filter pages, limit 128 characters.
  """
  pageType: String!

  """
  A primary image url for this page, can be generated from a Page ContentItem.
  """
  primaryImageUrl: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this page. Limit 128 characters."""
  slug: String!

  """Which storefronts should have access to this page?"""
  storefrontIds: [ID]

  """The subtitle of the page, limit 256 characters."""
  subtitle: String
  tags: [String]

  """The title of the page, limit 256 characters."""
  title: String!
}

"""Returned object from deletePage"""
type PageDeleteResponse {
  deletedId: ID!
}

"""One edge producing one Page Node"""
type PageEdge {
  node: Page
}

"""Input object for creating an Image for a Page from a File on a device"""
input PageImageFromFileInput {
  demandHqId: ID!
  fileExtension: String!
  fileName: String!
  pageId: ID!
}

"""Returned object from createPageImageFromFile"""
type PageImageFromFileResponse {
  """The contentItemId of the image"""
  contentItemId: ID!

  """Used while uploading the image"""
  fields: JSON!
  page: Page!

  """Used to upload the image"""
  url: String!
}

"""Input object for creating an Image for a Page from a URL"""
input PageImageFromUrlInput {
  demandHqId: ID!
  pageId: ID!
  url: String!
}

"""Information on Pagination"""
type PageInfo {
  """
  The cursor to use when paginating forwards (using first/after). Will always be
  populated regardless of if a next page exists.
  """
  endCursor: String

  """
  Whether or not using the endCursor will result in more results. Always
  populated, but will always be false when paginating using last/before.
  """
  hasNextPage: Boolean!

  """
  Whether or not using the startCursor will result in more results. Always
  populated, but will always be false when paginating using first/after.
  """
  hasPreviousPage: Boolean!

  """
  The cursor to use when paginating backwards (using last/before). Will always
  be populated regardless of if a previous page exists
  """
  startCursor: String
}

"""Indicates which field to sort by, defaults to CREATED_AT"""
enum PageSortField {
  CREATED_AT
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
}

"""Sort Pages by a field and direction."""
input PageSortInput {
  direction: SortDirection!
  field: PageSortField!
}

"""Indicates whether the user type is an app or human user"""
enum PageStatus {
  DRAFT
  PUBLISHED
}

"""Filter Pages using Status."""
input PageStatusFilterInput {
  operator: FilterOperator
  values: [PageStatus!]!
}

"""These are the tags associated to the page"""
type PageTags {
  demandHqId: ID!
  pageId: ID!

  """Get parsed, and optionally filtered, tags for a Page."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""A Map of several fields of Page and term aggregations for each"""
type PageTermAggregations {
  authors: [TermAggregation!]
  pageTypes: [TermAggregation!]
  tags: [TermAggregation!]
}

"""
ID Fields are required, but all other fields are optional, only included fields will be updated.
"""
input PageUpdateInput {
  """The author of the page, limit 256 characters."""
  author: String

  """
  The ContentItemIds of the Content Items that are associated with this page.
  """
  contentItemIds: [ID!]

  """A short description of the page, limit 1000 characters."""
  description: String
  pageId: ID!

  """
  Any string to declare a category of this page, can be used to filter pages, limit 128 characters.
  """
  pageType: String

  """
  A primary image url for this page, can be generated from a Page ContentItem.
  """
  primaryImageUrl: String

  """
  ISO format date when the page was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this page. Limit 128 characters."""
  slug: String

  """The status of the page, can be DRAFT or PUBLISHED."""
  status: PageStatus

  """Which storefronts should have access to this page?"""
  storefrontIds: [ID]

  """The subtitle of the page, limit 256 characters."""
  subtitle: String
  tags: [String]

  """The title of the page, limit 256 characters."""
  title: String
}

"""An up to 3-part tag, comma-separated, that has been parsed"""
type ParsedTag {
  """The category of the tag"""
  category: String

  """The key of the tag"""
  key: String

  """The value of the tag"""
  value: String!
}

"""
A Product is a part of the Demand Domain and represents a the basic information of a product.
Products have many support entities, including variants, which represent SKUs of the product.
"""
type Product {
  createdAt: Date!
  demandHqId: ID!

  """
  Get a single productLocale by ResonanceLocaleType
  
      Requires productlocale/read permission on the requesting identity
  """
  locale(localeType: ResonanceLocaleType!): ProductLocale

  """
  The labels for the possible option groups for this product, i.e. "Color", "Size", "Material", etc.
  These will match with labelOptions in Variants.
  """
  optionLabels: [String!]!
  productId: ID!

  """
  ISO format date when the product was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this product. Limit 128 characters."""
  slug: String!

  """The status of the product, can be DRAFT or PUBLISHED."""
  status: ProductStatus!

  """Which storefronts should have access to this product?"""
  storefrontIds: [ID]

  """Get the tags for this product"""
  tags: ProductTags

  """The title of the product, limit 256 characters."""
  title: String!
  updatedAt: Date!
  updatedBy: ID!

  """
  Get a single variant by VariantId
  
      Requires demandHqvariant/read permission on the requesting identity
  """
  variant(variantId: ID): Variant

  """
  Get a list of variants
  
      Requires demandHqvariant/read permission on the demandHq for the requesting identity
  """
  variants(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): VariantConnection!

  """AKA Brand. Limit 256 characters."""
  vendor: String!
}

"""Paginate through Products"""
type ProductConnectionWithSearch {
  edges: [ProductEdge]!
  nodes: [Product]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""
Exactly like Product, but no Status (Status is set to DRAFT on create).
"""
input ProductCreateInput {
  demandHqId: ID!

  """
  The labels for the possible option groups for this product, i.e. "Color", "Size", "Material", etc.
  These will match with labelOptions in Variants.
  """
  optionLabels: [String!]!

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this product. Limit 128 characters."""
  slug: String!

  """Which storefronts should have access to this product?"""
  storefrontIds: [ID]
  tags: [String]

  """The title of the product, limit 256 characters."""
  title: String!

  """AKA Brand. Limit 256 characters."""
  vendor: String!
}

"""Returned object from deleteProduct"""
type ProductDeleteResponse {
  deletedId: ID!
}

"""One edge producing one Product Node"""
type ProductEdge {
  node: Product
}

"""
This has a many to one relationship with Product, and provides localized language data for the appropriate fields.
There will often only be one of these, and it should be the one set in defaultLocale for the supplier.
"""
type ProductLocale {
  createdAt: String!
  demandHqId: ID!
  description: String

  """Limited to 5 bullets"""
  featureBullets: [String]
  localeType: ResonanceLocaleType!
  productId: ID!
  updatedAt: String!
  updatedBy: String!
}

"""The necessary fields in order to create a new productLocale"""
input ProductLocaleCreateInput {
  demandHqId: ID!
  description: String

  """Limited to 5 bullets"""
  featureBullets: [String]
  localeType: ResonanceLocaleType!
  productId: ID!
}

"""
The necessary fields in order to update a productLocale.
ID fields are required, others are optional, only included fields will be updated.
"""
input ProductLocaleUpdateInput {
  description: String

  """Limited to 5 bullets"""
  featureBullets: [String]
  localeType: ResonanceLocaleType!
  productId: ID!
}

"""Indicates which field to sort by, defaults to CREATED_AT"""
enum ProductSortField {
  CREATED_AT
  MSRP
  PRICE
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
  VENDOR
}

"""Sort Products by a field and direction."""
input ProductSortInput {
  direction: SortDirection!
  field: ProductSortField!
}

"""Filter Products using StandardizedColor (Variant)."""
input ProductStandardizedColorFilterInput {
  operator: FilterOperator
  values: [VariantStandardizedColor!]!
}

"""Indicates whether the user type is an app or human user"""
enum ProductStatus {
  ARCHIVED
  DRAFT
  NEEDSREVIEW
  PUBLISHED
}

"""Filter Products using Status."""
input ProductStatusFilterInput {
  operator: FilterOperator
  values: [ProductStatus!]!
}

"""These are the tags associated to the product"""
type ProductTags {
  demandHqId: ID!
  productId: ID!
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""A Map of several fields of Product and term aggregations for each"""
type ProductTermAggregations {
  manufacturers: [TermAggregation!]
  tags: [TermAggregation!]
  vendors: [TermAggregation!]
}

"""
ID Fields are required, but all other fields are optional, only included fields will be updated.
"""
input ProductUpdateInput {
  """
  The labels for the possible option groups for this product, i.e. "Color", "Size", "Material", etc.
  These will match with labelOptions in Variants.
  """
  optionLabels: [String!]
  productId: ID!

  """
  ISO format date when the product was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this product. Limit 128 characters."""
  slug: String

  """The status of the product, can be DRAFT or PUBLISHED."""
  status: ProductStatus

  """Which storefronts should have access to this product?"""
  storefrontIds: [ID]
  tags: [String]

  """The title of the product, limit 256 characters."""
  title: String

  """AKA Brand. Limit 256 characters."""
  vendor: String
}

"""
This type is returned on routes with no permissions attached to protect
Personally Identifiable Information, but still provide minimal data.
Provides a subset of App from the Identity domain.
"""
type PublicApp {
  appClientIds: [ID!]!
  appId: ID!
  appType: AppType!
  description: String
  name: String!
  partnerId: ID!
  requestedScopes: [String]
  status: AppStatus!
}

"""
This type is returned on routes with no permissions attached to protect
Personally Identifiable Information, but still provide minimal data.
Can be a User or AppClient.
"""
type PublicIdentity {
  displayName: String!

  """A userName or appClientId"""
  identityId: ID!
  identityParentEntityId: ID
}

"""
This type is the extension of DemandHqIdentity's identityParentEntityId into the Public version of the entity,
        and encompasses all possible uses of that field.
        Currently, this is for Apps only.
"""
union PublicIdentityParent = PublicApp

"""The root query type for the Demand domain"""
type Query {
  """Nothing to see here, just a workaround for Apollo Server"""
  _empty: String

  """
  Get a collection by collectionId.
              
  Required collection/read permission on the given DemandHq.
  """
  collection(collectionId: ID!): Collection

  """
  Get a Customer by their customerId.
              
  Requires the customer/read permission for the associated DemandHq.
  """
  customer(customerId: ID!): Customer

  """
  Get a single demandHq by DemandHqId
  
  Requires demandHq/read permission on the requesting identity
  """
  demandHq(demandHqId: ID!): DemandHq

  """
  Get a filtered list of DemandHqIdentities
  
  All of the filters are optional, but you must include at least one.
  You may receive less demandHqIdentities than you indicate if you do not have
  permission to read part of the result set.
  
  Not all filter combinations are valid, for example you cannot filter by
  - identityId + identityParentEntityId (requires demandHqId)
  - identityType only (requires demandHqId)
  
  Requires demandHqidentity/read permission on the requesting identity for each demandHq requested,
  or you can request your own identities.
  """
  demandHqIdentities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Filter the results to a specific demandHqId. (optional)"""
    demandHqId: ID

    """Returns the first n elements from the list."""
    first: Int

    """
    Filter the results to a specific identityId.
    Use this with your own userName or appClientId in order to see "My DemandHqIdentities".
    You automatically have access to your own DemandHqIdentities.
    """
    identityId: ID

    """Filter the results to a specific identityParentEntityId (optional)"""
    identityParentEntityId: ID

    """Filter the results to a specific identity type (optional)"""
    identityType: DemandHqIdentityType

    """Returns the last n elements from the list."""
    last: Int
  ): DemandHqIdentityConnection!

  """
  Get a single DemandHqIdentity
  
  Requires demandHqidentity/read permission on the requesting identity for the demandHq requested
  """
  demandHqIdentity(demandHqId: ID!, identityId: ID!): DemandHqIdentity

  """
  Get a Nav by its id.
              
  Requires the user to have the nav/read permission on the associated DemandHq.
  """
  nav(navId: ID!): Nav

  """
  Get a page by pageId.
              
  Required page/read permission on the given DemandHq.
  """
  page(pageId: ID!): Page

  """
  Get a single product by ID.
              
  Requires the product/read scope on the associated DemandHq.
  """
  product(productId: ID!): Product

  """
  Get a storefront by its storefrontId.
              
  Requires the storefront/read permission on the associated DemandHq.
  """
  storefront(storefrontId: ID!): Storefront

  """
  Retrieve the settings for a storefront's Navs
              
  Requires the storefrontnavsettings/read permission on the associated DemandHq.
  """
  storefrontNavSettings(storefrontId: ID!): StorefrontNavSettings

  """
  Get a single variant by VariantId
  
      Requires demandHqvariant/read permission on the requesting identity
  """
  variant(variantId: ID): Variant

  """
  Get several variants by VariantIds (currently)
  
      Requires demandHqvariant/read permission on the requesting identity for all associated demandHqs
  """
  variants(variantIds: [ID!]!): VariantConnection!
}

"""Used throughout the app to give a currency to price information"""
enum ResonanceCurrency {
  USD
}

"""
Used throughout the app to indicate what language and locality a given text is in
"""
enum ResonanceLocaleType {
  EN_US
}

"""Indicates which direction to sort, defaults to ASC"""
enum SortDirection {
  ASC
  DESC
}

"""
A Storefront represents a customer facing ecommerce website that consumes Resonance Demand Entities
"""
type Storefront {
  """Get an api key for this storefront by identitySlug."""
  apiKey(slug: String!): StorefrontApiKey

  """Get all api keys for this storefront."""
  apiKeys: [StorefrontApiKey]!
  authenticationSettings: StorefrontAuthenticationSettings
  authenticationType: StorefrontAuthenticationType
  createdAt: Date!

  """
  Get a Customer by their customerId.
              
  Requires the customer/read permission for the associated DemandHq.
  """
  customer(customerId: ID!): Customer

  """
  Get a list of Customers.
  
  Requires the customer/read permission for the associated DemandHq.
  """
  customers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    customerIds: [ID]

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): CustomerConnectionWithSearch!
  demandHqId: ID!
  description: String
  name: String!

  """
  List Navs for a storefront.
  
  Requires the user to have the nav/read permission on the associated DemandHq.
  """
  navs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int
    href: String
    hrefPrefix: String

    """Returns the last n elements from the list."""
    last: Int
    linkSlug: String
    linkType: String
    navIds: [ID]
    navLevel: Int
    navType: String
  ): NavConnection!
  storefrontId: ID!
  storefrontIdentities: [StorefrontIdentity!]
  updatedAt: Date!
  updatedBy: ID!
  urlDomain: String!
}

"""
The key of the storefront identity, gets base64 encoded and passed in headers with API requests
"""
type StorefrontApiKey {
  key: String!
  slug: String!
}

"""
Based on the authenticationType, these settings can have different shapes, but this type is all encompassing.
"""
type StorefrontAuthenticationSettings {
  """Used for authenticationType COGNITO."""
  issuer: String
}

"""
Necessary fields to set authentication related settings for a Storefront.
"""
input StorefrontAuthenticationSettingsInput {
  """Used for authenticationType COGNITO."""
  issuer: String
}

"""Indicates what type of authentication is used for the storefront."""
enum StorefrontAuthenticationType {
  COGNITO
  NONE
}

"""Paginate through Storefronts"""
type StorefrontConnection {
  edges: [StorefrontEdge]!
  nodes: [Storefront]!
  pageInfo: PageInfo!
}

"""Necessary fields to create a storefront."""
input StorefrontCreateInput {
  authenticationSettings: StorefrontAuthenticationSettingsInput
  authenticationType: StorefrontAuthenticationType
  demandHqId: ID!
  description: String
  name: String!
  storefrontIdentities: [StorefrontIdentityInput!]
  urlDomain: String!
}

"""One edge producing one Storefront Node"""
type StorefrontEdge {
  node: Storefront
}

"""
An identity that is associated with a storefront and is assigned scopes
"""
type StorefrontIdentity {
  permissions: StorefrontPermissions!

  """
  Human-readable way to categorize the use of this identity, must be unique to
  this storefront, all lowercase, and contain no spaces, limit 32 characters.
  """
  slug: String!
}

"""Necessary fields to create a Storefront Identity."""
input StorefrontIdentityInput {
  permissions: StorefrontPermissionsInput!

  """
  Human-readable way to categorize the use of this identity, must be unique to
  this storefront, all lowercase, and contain no spaces, limit 32 characters.
  """
  slug: String!
}

"""The settings for a storefront's Navs"""
type StorefrontNavSettings {
  createdAt: Date!
  demandHqId: ID!

  """
  This sets what linkTypes are allowed for Navs in this storefront. Helps correct human error.
  Maximum of 50 types.
  """
  linkTypes: [String]
  storefrontId: ID!
  updatedAt: Date!
  updatedBy: ID!
}

"""The input for upserting a StorefrontNavSettings"""
input StorefrontNavSettingsUpsertInput {
  demandHqId: ID!

  """
  This sets what linkTypes are allowed for Navs in this storefront. Helps correct human error.
  Maximum of 50 types.
  """
  linkTypes: [String]
  storefrontId: ID!
}

"""The permissions of the storefront identity"""
type StorefrontPermissions {
  roles: [StorefrontRole!]!
  scopes: [String!]!
}

"""Necessary fields to set permissions for a Storefront Identity."""
input StorefrontPermissionsInput {
  roles: [StorefrontRole!]!
  scopes: [String!]!
}

"""The roles of a storefront identity"""
enum StorefrontRole {
  CLIENT
  SERVER
}

"""
Necessary fields to update an existing storefront. Only the fields that are not null will be updated.
"""
input StorefrontUpdateInput {
  authenticationSettings: StorefrontAuthenticationSettingsInput
  authenticationType: StorefrontAuthenticationType
  description: String
  name: String
  storefrontId: ID!
  storefrontIdentities: [StorefrontIdentityInput!]
  urlDomain: String
}

"""Filter using a combination of operator and an array of string values"""
input StringFilterInput {
  operator: FilterOperator
  values: [String!]!
}

"""
Indicates the key of the term aggregation, and approximately how many documents it occurs in. 
"""
type TermAggregation {
  docCount: Int!
  key: String!
}

"""
The main item of the Supplier Domain, represents a single SKU of a product
Only the variant level exists, there is no parent product.
"""
type Variant {
  """UPC, ISBN, GTIN, etc."""
  barcode: String!

  """Quantity in one variant (i.e. 12-pack). Must be a positive integer."""
  casePack: Int

  """Associates contentItems with this variant"""
  contentItemIds: [ID]
  createdAt: String!
  demandHqId: ID!
  isTaxable: Boolean

  """Often same as vendor, but not always."""
  manufacturer: String

  """Minimum Advertised Price. Must be a positive number."""
  mapPrice: Float

  """Manufacturer Part Number"""
  mpn: String

  """Manufacturer's Suggested Retail Price. Must be a positive number."""
  msrp: Float

  """
  An array of the option values that make up this variant.
  For example, a product with a color and size option would have two option values,
  one for each of the color and size options, i.e. ["Red", "Small"]
  
  Must have 1-3, and it should match the number of options in the product, but there is no validation to do so.
  
  Set this to "No Option" if you don't want to use options for this product and this is the only variant.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionValues: [String!]!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int

  """Price for the defaultCurrency, can be any positive float number value."""
  price: Float!

  """
  Get the product this variant belongs to.
              
  Requires the product/read scope on the associated DemandHq.
  """
  product: Product
  productId: ID!
  shippingDimensions: VariantShippingDimensions

  """Stock Keeping Unit"""
  sku: String
  standardizedColor: VariantStandardizedColor

  """Get the title of this variant (combo of optionValues)"""
  title: String!
  updatedAt: String!
  updatedBy: String!
  variantId: ID!
  weight: VariantWeight
}

"""Paginate through Variants"""
type VariantConnection {
  edges: [VariantEdge]!
  nodes: [Variant]!
  pageInfo: PageInfo!
}

"""The necessary fields in order to create a new variant"""
input VariantCreateInput {
  """UPC, ISBN, GTIN, etc."""
  barcode: String!

  """Quantity in one variant (i.e. 12-pack). Must be a positive integer."""
  casePack: Int

  """Associates contentItems with this variant"""
  contentItemIds: [ID]
  demandHqId: ID!
  isTaxable: Boolean

  """Often same as vendor, but not always."""
  manufacturer: String

  """Minimum Advertised Price. Must be a positive number."""
  mapPrice: Float

  """Manufacturer Part Number"""
  mpn: String

  """Manufacturer's Suggested Retail Price. Must be a positive number."""
  msrp: Float

  """
  An array of the option values that make up this variant.
  For example, a product with a color and size option would have two option values,
  one for each of the color and size options, i.e. ["Red", "Small"]
  
  Must have 1-3, and it should match the number of options in the product, but there is no validation to do so.
  
  Set this to "No Option" if you don't want to use options for this product and this is the only variant.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionValues: [String!]!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int

  """Price for the defaultCurrency, can be any positive float number value."""
  price: Float!
  productId: ID!
  shippingDimensions: VariantShippingDimensionsInput

  """Stock Keeping Unit"""
  sku: String
  standardizedColor: VariantStandardizedColor
  weight: VariantWeightInput
}

"""Response for when deleting a variant"""
type VariantDeleteResponse {
  deletedId: ID!
}

"""One edge producing one Variant Node"""
type VariantEdge {
  node: Variant
}

"""Metric or Standard Dimension?"""
enum VariantShippingDimensionUnit {
  CM
  IN
}

"""Object to indicate all three shipping box dimensions and a unit"""
type VariantShippingDimensions {
  height: Float!
  length: Float!
  unit: VariantShippingDimensionUnit!
  width: Float!
}

"""The necessary fields in order to set Shipping Dimensions for a variant"""
input VariantShippingDimensionsInput {
  height: Float!
  length: Float!
  unit: VariantShippingDimensionUnit!
  width: Float!
}

"""Indicates a standardized color for a variant, i.e. Blue for 'Topaz'"""
enum VariantStandardizedColor {
  BEIGE
  BLACK
  BLUE
  BRONZE
  BROWN
  CLEAR
  GOLD
  GRAY
  GREEN
  MULTICOLOR
  OFFWHITE
  ORANGE
  PINK
  PURPLE
  RED
  SILVER
  WHITE
  YELLOW
}

"""The necessary fields in order to update an existing variant"""
input VariantUpdateInput {
  """UPC, ISBN, GTIN, etc."""
  barcode: String

  """Quantity in one variant (i.e. 12-pack). Must be a positive integer."""
  casePack: Int

  """Associates contentItems with this variant"""
  contentItemIds: [ID]
  isTaxable: Boolean

  """Often same as vendor, but not always."""
  manufacturer: String

  """Minimum Advertised Price. Must be a positive number."""
  mapPrice: Float

  """Manufacturer Part Number"""
  mpn: String

  """Manufacturer's Suggested Retail Price. Must be a positive number."""
  msrp: Float

  """
  An array of the option values that make up this variant.
  For example, a product with a color and size option would have two option values,
  one for each of the color and size options, i.e. ["Red", "Small"]
  
  Must have 1-3, and it should match the number of options in the product, but there is no validation to do so.
  
  Set this to "No Option" if you don't want to use options for this product and this is the only variant.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionValues: [String!]

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int

  """Price for the defaultCurrency, can be any positive float number value."""
  price: Float
  shippingDimensions: VariantShippingDimensionsInput

  """Stock Keeping Unit"""
  sku: String
  standardizedColor: VariantStandardizedColor
  variantId: ID!
  weight: VariantWeightInput
}

"""Object to indicate both amount and unit of weight."""
type VariantWeight {
  amount: Float!
  unit: VariantWeightUnit!
}

"""The necessary fields in order to set Weight for a variant"""
input VariantWeightInput {
  amount: Float!
  unit: VariantWeightUnit!
}

"""Metric or Standard Weight?"""
enum VariantWeightUnit {
  GRAMS
  LBS
}
