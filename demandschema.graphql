"""The globally used Address of Resonance"""
type Address {
  """The city of the address"""
  city: String!

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String!

  """The name associated with the address, i.e. the Person in the household"""
  name: String!

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String!

  """The state of the address"""
  state: String!

  """The first line of the street address"""
  streetAddress1: String!

  """The second line of the street address"""
  streetAddress2: String
}

"""The input type for an Address"""
input AddressInput {
  """The city of the address"""
  city: String!

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String!

  """The name associated with the address, i.e. the Person in the household"""
  name: String!

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String!

  """The state of the address"""
  state: String!

  """The first line of the street address"""
  streetAddress1: String!

  """The second line of the street address"""
  streetAddress2: String
}

"""
The response recieved when an app is installed or the permissions are updated
"""
type AppInstallationResponse {
  demandHqIdentities: [DemandHqIdentity]!
}

"""What stage and availability the app is in"""
enum AppStatus {
  """The app is in the process of being created"""
  DRAFT

  """The app is available to install, but only through shared links"""
  PRIVATE

  """The app is available to install, and is searchable/discoverable"""
  PUBLIC
}

"""
This is the primary determination of which permission scopes can be requested.
An app cannot be more than one of these.
If something cross domain needs to exist, it should be two apps and they can communicate.
"""
enum AppType {
  DEMANDHQAPP
  STOREFRONTAPP
  SUPPLIERAPP
}

"""
A Collection is a group of products, what may often be referred to as a "Category Page" of some variety.
In reality, a collection is far more flexible and can be used to represent any
product grouping, and the collectionType can help differentiate between them.
"""
type Collection {
  collectionId: ID!

  """
  Any string to declare a category of this collection, can be used to filter collections, limit 128 characters.
  """
  collectionType: String!

  """Get the content of the collection."""
  content: CollectionContent

  """
  The ContentItemIds of the Content Items that are associated with this collection.
  """
  contentItemIds: [ID!]

  """Get the content items of the collection."""
  contentItems: [CollectionContentItem]
  createdAt: Date!
  demandHqId: ID!

  """A short description of the collection, limit 1000 characters."""
  description: String

  """
  Get the description if it exists, or fallback to the excerpt of content for the collection.
  """
  descriptionOrExcerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String

  """
  This can be used to pin certain products to the top of a collection when using certain sorts.
  Max number of products is 20.
  """
  featuredProductIds: [ID]

  """
  A primary image url for this collection, can be generated from a Collection ContentItem.
  """
  primaryImageUrl: String

  """
  Returns the primary image URL if exists, otherwise attempts to construct an
  image url from the first (featured) image of the page.  If the primary image
  URL is a CDN URL, it can be passed width and height properties to return a resized image.
  """
  primaryImageUrlWithFallback(
    """The height of the image to return in pixels."""
    height: Int

    """The width of the image to return in pixels."""
    width: Int
  ): String

  """
  Paginate through products in a collection.
  
  Requires the product/read scope.
  """
  products(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Optionally filter by manufacturer."""
    manufacturer: [StringFilterInput]

    """Optionally filter by msrp."""
    msrp: [FloatRangeFilterInput]

    """
    The number of results to return for each term aggregation. Defaults to 0 for each.
    """
    numberOfTermAggregationResults: ProductNumberOfTermAggregations

    """Optionally filter by price."""
    price: [FloatRangeFilterInput]

    """Filter Products to a set of productIds"""
    productIds: [ID]

    """
    Query products for certain terms. Searches several fields, including
    product.tags, product.title, product.vendor, productLocales.description,
    productLocales.featureBullets, variant.barcode, variant.mpn, variant.sku
    """
    query: String

    """Filter Products to a set of slugs"""
    slugs: [String]

    """
    Sort Products by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [ProductSortInput]

    """Optionally filter by standardized color."""
    standardizedColor: [ProductStandardizedColorFilterInput]

    """Filter Products using Status."""
    status: DemandEntityStatusFilterInput

    """Optionally filter by storefrontIds."""
    storefrontIds: IDFilterInput

    """Filter Products using Tag Prefixes (starts with)."""
    tagPrefixes: [StringFilterInput]

    """Filter Products using Tags."""
    tags: [StringFilterInput]

    """Optionally filter by vendor."""
    vendor: StringFilterInput
  ): ProductConnectionWithSearch!

  """
  ISO format date when the collection was published. Note that ensuing updates
  with status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """
  A map of rules to determine whether a Product should be part of this Collection.
  """
  rules: CollectionRules

  """
  A secondary image url for this collection, often a logo or related item.
  """
  secondaryImageUrl: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this collection. Limit 128 characters."""
  slug: String!

  """The status of the collection, can be DRAFT or PUBLISHED."""
  status: DemandEntityStatus!

  """Which storefronts should have access to this collection?"""
  storefrontIds: [ID]

  """The subtitle of the collection, limit 256 characters."""
  subtitle: String

  """Get the tags of the collection."""
  tags: CollectionTags

  """The title of the collection, limit 256 characters."""
  title: String!
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through Collections"""
type CollectionConnectionWithSearch {
  edges: [CollectionEdge]!
  nodes: [Collection]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON

  """
  Values and the number of times they occur for the results of the query. These
  will be the same for every page of a query, and should only be fetched on the first page.
  """
  termAggregations: CollectionTermAggregations
}

"""This is the actual markdown content for the collection"""
type CollectionContent {
  collectionId: ID!

  """
  Get the markdown content of the collection as parsed HTML. Do not use this
  field without purifying or sanitizing the HTML in your webapp.
  """
  contentAsHtml: String
  contentAsString: String!
  demandHqId: ID!

  """Get an excerpt of the collection content."""
  excerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String

  """
  Get the secondary markdown content of the collection as parsed HTML. Do not
  use this field without purifying or sanitizing the HTML in your webapp.
  """
  secondaryContentAsHtml: String
  secondaryContentAsString: String
  updatedAt: String
  updatedBy: ID!
}

"""
These are content items that are associated with a collection, Images, Videos, etc
"""
type CollectionContentItem {
  contentExtension: String!
  contentItemId: ID!
  contentKey: String!
  contentType: String!
  demandHqId: ID!
}

"""Upsert collection content for an existing Collection"""
input CollectionContentUpsertInput {
  collectionId: ID!
  contentAsString: String!
  secondaryContentAsString: String
}

"""
Exactly like Collection, but no publishedAt or Status (Status is set to DRAFT on create).
"""
input CollectionCreateInput {
  """
  Any string to declare a category of this collection, can be used to filter collections, limit 128 characters.
  """
  collectionType: String!

  """
  The ContentItemIds of the Content Items that are associated with this collection.
  """
  contentItemIds: [ID!]
  demandHqId: ID!

  """A short description of the collection, limit 1000 characters."""
  description: String

  """
  A primary image url for this collection, can be generated from a Collection ContentItem.
  """
  primaryImageUrl: String

  """
  A map of rules to determine whether a Product should be part of this Collection.
  """
  rules: CollectionRulesInput

  """
  A secondary image url for this collection, often a logo or related item.
  """
  secondaryImageUrl: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this collection. Limit 128 characters."""
  slug: String!

  """Which storefronts should have access to this collection?"""
  storefrontIds: [ID]

  """The subtitle of the collection, limit 256 characters."""
  subtitle: String
  tags: [String]

  """The title of the collection, limit 256 characters."""
  title: String!
}

"""Returned object from deleteCollection"""
type CollectionDeleteResponse {
  deletedId: ID!
}

"""One edge producing one Collection Node"""
type CollectionEdge {
  node: Collection
}

"""The input for creating an Image for a Collection from a file"""
input CollectionImageFromFileInput {
  collectionId: ID!
  demandHqId: ID!
  fileExtension: String!
  fileName: String!
}

"""The original input that errored"""
type CollectionImageFromFileInputResponse {
  collectionId: ID!
  demandHqId: ID!
  fileExtension: String!
  fileName: String!
}

"""Returned object from createCollectionImageFromFile"""
type CollectionImageFromFileResponse {
  collection: Collection!

  """The contentItemId of the image"""
  contentItemId: ID!

  """Used while uploading the image"""
  fields: JSON!

  """Used to upload the image"""
  url: String!
}

"""Returned object from createCollectionImagesFromFiles"""
type CollectionImageFromFilesResponse {
  errors: [CollectionImagesFromFilesError!]

  """
  A signed S3 url to upload the image to along with supporting data about the image
  """
  mutationResponses: [CollectionImageFromFileResponse!]!
}

"""Input object for creating an Image for a Collection from a URL"""
input CollectionImageFromUrlInput {
  collectionId: ID!
  demandHqId: ID!
  url: String!
}

"""Returned object for any failed CreateCollectionImagesFromFiles inputs"""
type CollectionImagesFromFilesError {
  """The error message"""
  error: String!
  input: CollectionImageFromFileInputResponse!
}

"""
The number of results to return for each term aggregation. Defaults to 0 for each.
"""
input CollectionNumberOfTermAggregations {
  collectionTypes: Int
  tags: Int
}

"""A rule to determine whether a Product should be part of a Collection."""
type CollectionRule {
  """The field to match against"""
  field: CollectionRuleField!

  """The operator to use when matching"""
  operator: CollectionRuleOperator!

  """The value to match against"""
  value: String!
}

"""Indicates which field a CollectionRule applies to"""
enum CollectionRuleField {
  TAG
  VENDOR
}

"""Input object to set a rule for a Collection"""
input CollectionRuleInput {
  """The field to match against"""
  field: CollectionRuleField!

  """The operator to use when matching"""
  operator: CollectionRuleOperator!

  """The value to match against"""
  value: String!
}

"""
Indicates how the value of the CollectionRuleField should be matched to actual values.
Note that for "NOT" functionality, you should instead include the whole CollectionRule in the "not" array.
"""
enum CollectionRuleOperator {
  EQUALS
}

"""
The rules to determine whether a Product should be part of a Collection.
"""
type CollectionRules {
  """ALL of the rules for this array must match a given prospective Product"""
  all: [CollectionRule]

  """ANY of the rules for this array must match a given prospective Product"""
  any: [CollectionRule]

  """
  If rules in this array match, a prospective Product should be excluded from the Collection
  """
  not: [CollectionRule]
}

"""Input object to set rules for a Collection"""
input CollectionRulesInput {
  """ALL of the rules for this array must match a given prospective Product"""
  all: [CollectionRuleInput]

  """ANY of the rules for this array must match a given prospective Product"""
  any: [CollectionRuleInput]

  """
  If rules in this array match, a prospective Product should be excluded from the Collection
  """
  not: [CollectionRuleInput]
}

"""Indicates which field to sort by, defaults to CREATED_AT"""
enum CollectionSortField {
  CREATED_AT
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
}

"""Sort Collections by a field and direction."""
input CollectionSortInput {
  direction: SortDirection!
  field: CollectionSortField!
}

"""These are the tags associated to the collection"""
type CollectionTags {
  collectionId: ID!
  demandHqId: ID!

  """Get parsed, and optionally filtered, tags for a Collection."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""A Map of several fields of Collection and term aggregations for each"""
type CollectionTermAggregations {
  collectionTypes: [TermAggregation!]
  tags: [TermAggregation!]
}

"""
This holds content specific to a collectionType. This is generally used on a
page that lists all collections for a collectionType.
"""
type CollectionTypeContent {
  collectionType: String!
  collectionTypeContentId: ID!

  """
  Get the markdown content of the collectionTypeContent as parsed HTML. Do not
  use this field without purifying or sanitizing the HTML in your webapp.
  """
  contentAsHtml: String
  contentAsString: String
  createdAt: Date!
  demandHqId: ID!

  """
  A short description of the collectionTypeContent, limit 1000 characters. This
  is typically used off of the collectionTypeContent page itself.
  """
  description: String

  """
  Get the description if it exists, or fallback to the excerpt of content for the CollectionTypeContent.
  """
  descriptionOrExcerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String

  """Get an excerpt of the CollectionTypeContent."""
  excerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String

  """
  Get the secondary markdown content of the collectionTypeContent as parsed
  HTML. Do not use this field without purifying or sanitizing the HTML in your webapp.
  """
  secondaryContentAsHtml: String
  secondaryContentAsString: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String
  storefrontId: ID!

  """The subtitle of the collectionTypeContent, limit 256 characters."""
  subtitle: String

  """
  These tags function in the opposite direction of other tags, allowing you to
  choose several to focus on while displaying the content.
  Commonly, these are used to filter or categorize content by providing options that match tags on the content itself.
  """
  tags: CollectionTypeContentTags

  """The title of the collectionTypeContent, limit 256 characters."""
  title: String
  updatedAt: Date!
  updatedBy: ID!
}

"""Pagination object for CollectionTypeContent."""
type CollectionTypeContentConnection {
  edges: [CollectionTypeContentEdge]!
  nodes: [CollectionTypeContent]!
  pageInfo: PageInfo!
}

"""Input object to create a CollectionTypeContent."""
input CollectionTypeContentCreateInput {
  collectionType: String!
  contentAsString: String
  demandHqId: ID!

  """
  A short description of the collectionTypeContent, limit 1000 characters. This
  is typically used off of the collectionTypeContent page itself.
  """
  description: String
  secondaryContentAsString: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String
  storefrontId: ID!

  """The subtitle of the collectionTypeContent, limit 256 characters."""
  subtitle: String

  """
  These tags function in the opposite direction of other tags, allowing you to
  choose several to focus on while displaying the content.
  Commonly, these are used to filter or categorize content by providing options that match tags on the content itself.
  """
  tags: CollectionTypeContentTagsInput

  """The title of the collectionTypeContent, limit 256 characters."""
  title: String
}

"""This is the response from a deleteCollectionTypeContent mutation."""
type CollectionTypeContentDeletedResponse {
  deletedId: String!
}

"""An edge containing a CollectionTypeContent."""
type CollectionTypeContentEdge {
  node: CollectionTypeContent
}

"""
These tags function in the opposite direction of other tags, allowing you to
choose several to focus on while displaying the content.
Commonly, these are used to filter or categorize content by providing options that match tags on the content itself.
"""
type CollectionTypeContentTags {
  """Get parsed, and optionally filtered, tags for a Page."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String!]
}

"""Input object to create CollectionTypeContentTags."""
input CollectionTypeContentTagsInput {
  raw: [String!]
}

"""Input object to update a CollectionTypeContent."""
input CollectionTypeContentUpdateInput {
  collectionTypeContentId: ID!
  contentAsString: String

  """
  A short description of the collectionTypeContent, limit 1000 characters. This
  is typically used off of the collectionTypeContent page itself.
  """
  description: String
  secondaryContentAsString: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """The subtitle of the collectionTypeContent, limit 256 characters."""
  subtitle: String

  """
  These tags function in the opposite direction of other tags, allowing you to
  choose several to focus on while displaying the content.
  Commonly, these are used to filter or categorize content by providing options that match tags on the content itself.
  """
  tags: CollectionTypeContentTagsInput

  """The title of the collectionTypeContent, limit 256 characters."""
  title: String
}

"""
ID Fields are required, but all other fields are optional, only included fields will be updated.
"""
input CollectionUpdateInput {
  collectionId: ID!

  """
  Any string to declare a category of this collection, can be used to filter collections, limit 128 characters.
  """
  collectionType: String

  """
  The ContentItemIds of the Content Items that are associated with this collection.
  """
  contentItemIds: [ID!]

  """A short description of the collection, limit 1000 characters."""
  description: String

  """
  A primary image url for this collection, can be generated from a Collection ContentItem.
  """
  primaryImageUrl: String

  """
  ISO format date when the collection was published. Note that ensuing updates
  with status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """
  A map of rules to determine whether a Product should be part of this Collection.
  """
  rules: CollectionRulesInput

  """
  A secondary image url for this collection, often a logo or related item.
  """
  secondaryImageUrl: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this collection. Limit 128 characters."""
  slug: String

  """The status of the collection, can be DRAFT or PUBLISHED."""
  status: DemandEntityStatus

  """Which storefronts should have access to this collection?"""
  storefrontIds: [ID]

  """The subtitle of the collection, limit 256 characters."""
  subtitle: String
  tags: [String]

  """The title of the collection, limit 256 characters."""
  title: String
}

"""
A customer of a given Storefront is a user who places orders on the Storefront
"""
type Customer {
  createdAt: Date!

  """
  Get a CustomerAddress by their customerAddressId.
              
  Requires the customeraddress/read permission for the associated DemandHq.
  """
  customerAddress(customerAddressId: ID!): CustomerAddress

  """
  Get a list of CustomerAddresses.
  
  Requires the customeraddress/read permission for the associated DemandHq.
  """
  customerAddresses(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    customerAddressIds: [ID]

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): CustomerAddressConnection!
  customerId: ID!

  """
  Get the default billing address for a customer.
  
  Requires the customeraddress/read permission for the associated DemandHq.
  """
  defaultBillingAddress: CustomerAddress

  """
  The CustomerAddressId for the default billing address for this Customer
  """
  defaultBillingAddressId: ID

  """
  Get the default shipping address for a customer.
  
  Requires the customeraddress/read permission for the associated DemandHq.
  """
  defaultShippingAddress: CustomerAddress

  """
  The CustomerAddressId for the default shipping address for this Customer
  """
  defaultShippingAddressId: ID
  demandHqId: ID!

  """
  The email address associated with the Customer, must be unique to the storefront, limit 256 characters
  """
  emailAddress: String!
  emailMarketingConsent: CustomerMarketingConsent

  """
  Reference to the storefront's customer authentication system. Limit 256 characters.
  This field is required if this customer is going to access any authenticated data (like their orders).
  """
  externalCustomerId: ID

  """The first name of the Customer, limit 256 characters"""
  firstName: String

  """The last name of the Customer, limit 256 characters"""
  lastName: String

  """
  Must be unique to the Storefront. Limit 64 characters. Format +11231231234
  """
  phoneNumber: String
  smsMarketingConsent: CustomerMarketingConsent
  status: CustomerStatus!
  storefrontId: ID!

  """Get the tags of the customer."""
  tags: CustomerTags
  updatedAt: Date!
  updatedBy: ID!
}

"""
A customerAddress is an Address entity that is associated with a customer
"""
type CustomerAddress {
  """The city of the address"""
  city: String!

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String!
  createdAt: Date!
  customerAddressId: ID!
  customerId: ID!
  demandHqId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String!

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String!

  """The state of the address"""
  state: String!
  storefrontId: ID!

  """The first line of the street address"""
  streetAddress1: String!

  """The second line of the street address"""
  streetAddress2: String
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through CustomerAddresses"""
type CustomerAddressConnection {
  edges: [CustomerAddressEdge]!
  nodes: [CustomerAddress]!
  pageInfo: PageInfo!
}

"""Input for creating a CustomerAddress"""
input CustomerAddressCreateInput {
  """The city of the address"""
  city: String!

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String!
  customerId: ID!
  demandHqId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String!

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String!

  """The state of the address"""
  state: String!
  storefrontId: ID!

  """The first line of the street address"""
  streetAddress1: String!

  """The second line of the street address"""
  streetAddress2: String
}

"""One edge producing one CustomerAddress Node"""
type CustomerAddressEdge {
  node: CustomerAddress
}

"""Input for updating a CustomerAddress"""
input CustomerAddressUpdateInput {
  """The city of the address"""
  city: String

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String
  customerAddressId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String

  """The state of the address"""
  state: String

  """The first line of the street address"""
  streetAddress1: String

  """The second line of the street address"""
  streetAddress2: String
}

"""Paginate through Customers"""
type CustomerConnectionWithSearch {
  edges: [CustomerEdge]!
  nodes: [Customer]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""Input for creating a Customer"""
input CustomerCreateInput {
  """
  The CustomerAddressId for the default billing address for this Customer
  """
  defaultBillingAddressId: ID

  """
  The CustomerAddressId for the default shipping address for this Customer
  """
  defaultShippingAddressId: ID
  demandHqId: ID!

  """
  The email address associated with the Customer, must be unique to the storefront, limit 256 characters
  """
  emailAddress: String!
  emailMarketingConsent: CustomerMarketingConsentInput

  """
  Reference to the storefront's customer authentication system. Limit 256 characters.
  This field is required if this customer is going to access any authenticated data (like their orders).
  """
  externalCustomerId: ID

  """The first name of the Customer, limit 256 characters"""
  firstName: String

  """The last name of the Customer, limit 256 characters"""
  lastName: String

  """
  Must be unique to the Storefront. Limit 64 characters. Format +11231231234
  """
  phoneNumber: String
  smsMarketingConsent: CustomerMarketingConsentInput
  status: CustomerStatus!
  storefrontId: ID!
  tags: [String]
}

"""One edge producing one Customer Node"""
type CustomerEdge {
  node: Customer
}

"""Details about the Customer's marketing consent"""
type CustomerMarketingConsent {
  """The level at which the Customer has consented to marketing"""
  consentLevel: CustomerMarketingConsentLevel!

  """The date the associated Customer agreed to the marketing consent"""
  consentedAt: Date!
  hasConsented: Boolean!

  """Optional field to store where consent was sourced from"""
  source: String
}

"""Input for updating a Customer's marketing consent"""
input CustomerMarketingConsentInput {
  """The level at which the Customer has consented to marketing"""
  consentLevel: CustomerMarketingConsentLevel!

  """The date the associated Customer agreed to the marketing consent"""
  consentedAt: Date!
  hasConsented: Boolean!

  """Optional field to store where consent was sourced from"""
  source: String
}

"""The level at which the Customer has opted-in to Marketing."""
enum CustomerMarketingConsentLevel {
  """Level 3"""
  CONFIRMED_OPT_IN

  """Level 1"""
  SINGLE_OPT_IN

  """Level 2"""
  SINGLE_OPT_IN_WITH_NOTIFICATION
  UNKNOWN
}

"""The status of the associated Customer"""
enum CustomerStatus {
  """The associated Customer is active and able to login"""
  ACTIVE

  """The associated Customer is not active and unable to login"""
  DISABLED

  """The associated Customer is active, but has not yet setup a login"""
  GUEST
}

"""These are the tags associated to the Customer"""
type CustomerTags {
  customerId: ID!
  demandHqId: ID!

  """Get parsed, and optionally filtered, tags for a Customer."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""Input for updating a Customer"""
input CustomerUpdateInput {
  customerId: ID!

  """
  The CustomerAddressId for the default billing address for this Customer
  """
  defaultBillingAddressId: ID

  """
  The CustomerAddressId for the default shipping address for this Customer
  """
  defaultShippingAddressId: ID

  """
  The email address associated with the Customer, must be unique to the storefront, limit 256 characters
  """
  emailAddress: String
  emailMarketingConsent: CustomerMarketingConsentInput

  """
  Reference to the storefront's customer authentication system. Limit 256 characters.
  This field is required if this customer is going to access any authenticated data (like their orders).
  """
  externalCustomerId: ID

  """The first name of the Customer, limit 256 characters"""
  firstName: String

  """The last name of the Customer, limit 256 characters"""
  lastName: String

  """
  Must be unique to the Storefront. Limit 64 characters. Format +11231231234
  """
  phoneNumber: String
  smsMarketingConsent: CustomerMarketingConsentInput
  status: CustomerStatus
  tags: [String]
}

"""A date in ISO 8601 format"""
scalar Date

"""Returned object from deleteCollectionContentItem"""
type DeleteCollectionContentItemResponse {
  """The contentItemId of the contentItem that was deleted."""
  deletedId: ID!
}

"""Returned object from deleteCustomerAddress"""
type DeleteCustomerAddressResponse {
  """The customerAddressId of the customerAddress that was deleted."""
  deletedId: ID!
}

"""Returned object from deleteCustomer"""
type DeleteCustomerResponse {
  """The customerId of the customer that was deleted."""
  deletedId: ID!
}

"""The response from a delete request."""
type DeleteNavResponse {
  deletedId: ID!
}

"""Returned object from deletePageContentItem"""
type DeletePageContentItemResponse {
  """The contentItemId of the contentItem that was deleted."""
  deletedId: ID!
}

"""
Indicates what stage of creation a Demand Entity is in, i.e. a Collection, Page, or Product
"""
enum DemandEntityStatus {
  ARCHIVED
  DRAFT
  NEEDSREVIEW
  PUBLISHED
}

"""Filter using DemandEntityStatus."""
input DemandEntityStatusFilterInput {
  operator: FilterOperator
  values: [DemandEntityStatus!]!
}

"""
Contains before and after snapshots for every event that occurs within the Demand domain
"""
type DemandEvent {
  """
  This is the event data and metadata.
  The data is variable, but most typically contains a newItem and oldItem.
  """
  message: DemandEventMessage

  """UUID"""
  messageId: String!

  """A human-friendly string summarizing the event"""
  subject: String

  """ISO Date that the event occurred"""
  timestamp: Date!
}

"""Paginate through DemandEvents"""
type DemandEventConnection {
  edges: [DemandEventEdge]!
  nodes: [DemandEvent]!
  pageInfo: PageInfo!
}

"""One edge producing one DemandEvent Node"""
type DemandEventEdge {
  node: DemandEvent
}

"""
This is the event data and metadata.
The data is variable, but most typically contains a newItem and oldItem.
"""
type DemandEventMessage {
  """Variable, but most typically contains a newItem and oldItem."""
  data: JSON

  """Items consistent to every event"""
  metadata: DemandEventMetadata
}

"""Items consistent to every event"""
type DemandEventMetadata {
  domain: String!

  """This is most typically supplierId or demandHqId"""
  domainEntityId: ID!
  entityId: ID
  identityId: ID
  itemType: String
  mutationType: String
  status: String
  syncedAt: Int
  updatedBy: String
}

"""The parent-most entity of the DemandHq Domain"""
type DemandHq {
  """
  Get a collection by collectionId or slug (one must be provided).
              
  Required collection/read permission on the given DemandHq.
  """
  collection(collectionId: ID, slug: String): Collection!

  """
  Term aggregations for Collections, typically used to suggest terms to use in Search Filters.
  """
  collectionTermAggregations(
    """The number of aggregations to return for each type."""
    numberOfResults: Int!
  ): CollectionTermAggregations

  """
  List collections for a DemandHq with optional filters.
              
  Required collection/read permission on the given DemandHq.
  """
  collections(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Filter Collections to a set of collectionIds"""
    collectionIds: [ID]

    """Filter Collections using collectionType"""
    collectionType: StringFilterInput

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """
    The number of results to return for each term aggregation. Defaults to 0 for each.
    """
    numberOfTermAggregations: CollectionNumberOfTermAggregations

    """
    Query collections for certain terms. Searches several fields, including
    collection.description, collection.subtitle, collection.title,
    collectionTags, and the actual primary and secondary content of the collection.
    """
    query: String

    """Filter Collections to a set of slugs"""
    slugs: [String]

    """
    Sort Collections by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [CollectionSortInput]

    """Filter Collections using status"""
    status: DemandEntityStatusFilterInput

    """Optionally filter by storefrontIds."""
    storefrontIds: IDFilterInput

    """Filter Collections using Tag Prefixes (starts with)."""
    tagPrefixes: [StringFilterInput]

    """Filter Collections using Tags."""
    tags: [StringFilterInput]
  ): CollectionConnectionWithSearch!
  createdAt: String!
  defaultCurrency: ResonanceCurrency!
  defaultLocaleType: ResonanceLocaleType!
  demandHqId: ID!

  """
  Returns DemandHqIdentities for the given DemandHq
  
  Requires demandHqidentity/read permission on the requesting identity
  """
  demandHqIdentities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Filter the results to a specific identityParentEntityId (optional)"""
    identityParentEntityId: ID

    """Filter the results to a specific identity type (optional)"""
    identityType: DemandHqIdentityType

    """Returns the last n elements from the list."""
    last: Int
  ): DemandHqIdentityConnection!

  """
  Returns a DemandHqIdentity for the given DemandHq
  
  Requires demandHqidentity/read permission on the requesting identity, or you can request your own identity.
  """
  demandHqIdentity(demandHqId: ID!, identityId: ID!): DemandHqIdentity

  """
  Get a DemandHqSupplier by SupplierId.
              
  Requires the requesting identity to have the "demandhqsupplier/read" permission on the associated DemandHq.
  """
  demandHqSupplier(supplierId: ID!): DemandHqSupplier

  """
  Get a list of DemandHqSuppliers for a DemandHQ.
  
  Requires the requesting identity to have the "demandhqsupplier/read" permission on the associated DemandHq.
  """
  demandHqSuppliers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
    status: DemandHqSupplierStatus
  ): DemandHqSupplierConnection!
  demandSubscriptionCodes: [DemandSubscriptionCode!]
  description: String
  name: String!

  """
  These users will get notified if something requires attention for this DemandHq.
  If none are provided, ownerUserName will be notified.
  """
  notificationUserNames: DemandHqNotificationUserNames

  """
  Get an order for an orderId.
              
  Requires the order/read scope on the associated DemandHq.
  """
  order(orderId: ID!): Order

  """
  Get a list of orders for a DemandHq.
  
  Requires the order/read scope on the associated DemandHq.
  """
  orders(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
    orderIds: [ID]
  ): OrderConnection!

  """Get a public identity for the owner of this DemandHq"""
  ownerUser: PublicIdentity
  ownerUserName: String!

  """
  Get a page by pageId or slug (one must be provided).
              
  Required page/read permission on the given DemandHq.
  """
  page(pageId: ID, slug: String): Page!

  """
  Term aggregations for Pages, typically used to suggest terms to use in Search Filters.
  """
  pageTermAggregations(
    """The number of aggregations to return for each type."""
    numberOfResults: Int!
  ): PageTermAggregations

  """
  List pages for a DemandHq with optional filters.
              
  Required page/read permission on the given DemandHq.
  """
  pages(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Filter Pages using author"""
    author: StringFilterInput

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """
    The number of results to return for each term aggregation. Defaults to 0 for each.
    """
    numberOfTermAggregations: PageNumberOfTermAggregations

    """Filter Pages to a set of pageIds"""
    pageIds: [ID]

    """Filter Pages using pageType"""
    pageType: StringFilterInput

    """
    Query pages for certain terms. Searches several fields, including
    page.author, page.description, page.subtitle, page.title, pageTags, and the
    actual content of the page.
    """
    query: String

    """Filter Pages to a set of slugs"""
    slugs: [String]

    """
    Sort Pages by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [PageSortInput]

    """Filter Pages using status"""
    status: DemandEntityStatusFilterInput

    """Optionally filter by storefrontIds."""
    storefrontIds: IDFilterInput

    """Filter Pages using Tag Prefixes (starts with)."""
    tagPrefixes: [StringFilterInput]

    """Filter Pages using Tags."""
    tags: [StringFilterInput]
  ): PageConnectionWithSearch!

  """
  Get a single product by ID or slug.
  
  Requires the product/read scope on the associated DemandHq.
  """
  product(productId: ID, slug: String): Product

  """
  Term aggregations for Products, typically used to suggest terms to use in Search Filters.
  """
  productTermAggregations(
    """The number of aggregations to return for each type."""
    numberOfResults: Int!
  ): ProductTermAggregations

  """
  Get a list of products.
  
  Requires the product/read scope on the associated DemandHq.
  """
  products(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Optionally filter by manufacturer."""
    manufacturer: [StringFilterInput]

    """Optionally filter by msrp."""
    msrp: [FloatRangeFilterInput]

    """
    The number of results to return for each term aggregation. Defaults to 0 for each.
    """
    numberOfTermAggregationResults: ProductNumberOfTermAggregations

    """Optionally filter by price."""
    price: [FloatRangeFilterInput]

    """Filter Products to a set of productIds"""
    productIds: [ID]

    """
    Query products for certain terms. Searches several fields, including
    product.tags, product.title, product.vendor, productLocales.description,
    productLocales.featureBullets, variant.barcode, variant.mpn, variant.sku
    """
    query: String

    """Filter Products to a set of slugs"""
    slugs: [String]

    """
    Sort Products by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [ProductSortInput]

    """Optionally filter by standardized color."""
    standardizedColor: [ProductStandardizedColorFilterInput]

    """Filter Products using Status."""
    status: DemandEntityStatusFilterInput

    """Optionally filter by storefrontIds."""
    storefrontIds: IDFilterInput

    """Filter Products using Tag Prefixes (starts with)."""
    tagPrefixes: [StringFilterInput]

    """Filter Products using Tags."""
    tags: [StringFilterInput]

    """Optionally filter by vendor."""
    vendor: StringFilterInput
  ): ProductConnectionWithSearch!
  status: DemandHqStatus!

  """
  Get a storefront by its storefrontId.
              
  Requires the storefront/read permission on the associated DemandHq.
  """
  storefront(storefrontId: ID!): Storefront

  """
  List storefronts for a DemandHq.
              
  Requires the storefront/read permission on the associated DemandHq.
  """
  storefronts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): StorefrontConnection
  updatedAt: String!
  updatedBy: ID!
}

"""The necessary fields in order to create a new demandHq"""
input DemandHqCreateInput {
  defaultCurrency: ResonanceCurrency!
  defaultLocaleType: ResonanceLocaleType!
  demandSubscriptionCodes: [DemandSubscriptionCode!]
  description: String
  name: String!

  """
  These users will get notified if something requires attention for this DemandHq.
  If none are provided, ownerUserName will be notified.
  """
  notificationUserNames: DemandHqNotificationUserNamesInput
}

"""Indicates a User or App has permissions on a DemandHq"""
type DemandHqIdentity {
  """Get the demandHq associated with this DemandHqIdentity."""
  demandHq: DemandHq
  demandHqId: ID!

  """Could be a userName or an appClientId"""
  identityId: ID!
  identityParentEntityId: ID
  identityType: DemandHqIdentityType!
  permissions: DemandHqIdentityPermissions!

  """Get a public identity for this DemandHqIdentity"""
  publicIdentity: PublicIdentity

  """Get the expanded PublicIdentityParent for this DemandHqIdentity"""
  publicIdentityParent: PublicIdentityParent
  updatedBy: String!
}

"""Paginate through DemandHqIdentities"""
type DemandHqIdentityConnection {
  edges: [DemandHqIdentityEdge]!
  nodes: [DemandHqIdentity]!
  pageInfo: PageInfo!
}

"""
Exactly like DemandHqIdentity, but no updatedBy or identityType (always User, Apps get installed)
"""
input DemandHqIdentityCreateInput {
  demandHqId: ID!

  """Always a user's userName (not appClientId)"""
  identityId: ID!
  identityParentEntityId: ID

  """Should always be USER"""
  identityType: DemandHqIdentityType!
  permissions: DemandHqIdentityPermissionsInput!
}

"""Returned object from deleteDemandHqIdentity"""
type DemandHqIdentityDeleteResponse {
  deletedId: DemandHqIdentityDeletedId
}

"""The deleted IDs identifying the DemandHqIdentity"""
type DemandHqIdentityDeletedId {
  demandHqId: ID!
  identityId: ID!
}

"""One edge producing one DemandHqIdentity Node"""
type DemandHqIdentityEdge {
  node: DemandHqIdentity
}

"""
Indicates which permissions this Identity possesses on a given DemandHq
"""
type DemandHqIdentityPermissions {
  roles: [String]!
  scopes: [String]!
}

"""Exactly like DemandHqIdentityPermissions"""
input DemandHqIdentityPermissionsInput {
  roles: [String]!
  scopes: [String]!
}

"""Indicates whether the user type is an app or human user"""
enum DemandHqIdentityType {
  APPCLIENT
  USER
}

"""
ID Fields are required, but all other fields are optional, only included fields will be updated.
"""
input DemandHqIdentityUpdateInput {
  demandHqId: ID!

  """Could be a userName or an appClientId"""
  identityId: ID!
  permissions: DemandHqIdentityPermissionsInput
}

"""
These users will get notified if something requires attention for this DemandHq.
If none are provided, ownerUserName will be notified.
"""
type DemandHqNotificationUserNames {
  """All notifications for the catalog side (Products, Variants, etc.)."""
  catalog: [String!]

  """All notifications for the commerce side, besides orders."""
  commerce: [String!]

  """
  These are part of commerce, but are a specific enough case to be handled separately.
  """
  orders: [String!]
}

"""Exactly like DemandHqNotificationUserNames"""
input DemandHqNotificationUserNamesInput {
  """All notifications for the catalog side (Products, Variants, etc.)."""
  catalog: [String!]

  """All notifications for the commerce side, besides orders."""
  commerce: [String!]

  """
  These are part of commerce, but are a specific enough case to be handled separately.
  """
  orders: [String!]
}

"""Indicates the status of a DemandHq"""
enum DemandHqStatus {
  ARCHIVED
  PUBLISHED
}

"""A relationship between a Supplier and a DemandHQ."""
type DemandHqSupplier {
  createdAt: Date!
  demandHqId: ID!

  """Get the expanded PublicSupplier for this DemandHqSupplier"""
  publicSupplier: PublicSupplier

  """
  Indicates what status the current relationship between a Supplier and a DemandHQ is in.
  """
  status: DemandHqSupplierStatus!
  supplierId: ID!

  """
  If populated, this means that the last update was from the associated DemandHQ (typically a REQUEST).
  """
  syncedAt: Date
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through DemandHqSuppliers"""
type DemandHqSupplierConnection {
  edges: [DemandHqSupplierEdge]!
  nodes: [DemandHqSupplier]!
  pageInfo: PageInfo!
}

"""One edge producing one DemandHqSupplier Node"""
type DemandHqSupplierEdge {
  node: DemandHqSupplier
}

"""
Indicates what status the current relationship between a Supplier and a DemandHQ is in.
"""
enum DemandHqSupplierStatus {
  """The DemandHq has permission to sell items from the Supplier."""
  APPROVED

  """The Supplier has denied permission to the DemandHQ to sell its items."""
  DENIED

  """The DemandHq has requested permission to sell items from the Supplier."""
  PENDING
}

"""The possible fields in order to update a demandHq."""
input DemandHqUpdateInput {
  demandHqId: ID!
  demandSubscriptionCodes: [DemandSubscriptionCode!]
  description: String
  name: String

  """
  These users will get notified if something requires attention for this DemandHq.
  If none are provided, ownerUserName will be notified.
  """
  notificationUserNames: DemandHqNotificationUserNamesInput
  ownerUserName: String
}

"""Codes that signify a DemandSubscription"""
enum DemandSubscriptionCode {
  BETAMAX
}

"""Indicates how a filter should behave, defaults to OR"""
enum FilterOperator {
  AND
  NOT
  OR
}

"""
Filter using a min/max number range, in combination these function like an 'Any' filter.
"""
input FloatRangeFilterInput {
  max: Float!
  min: Float!
}

"""Filter using a combination of operator and an array of ID values"""
input IDFilterInput {
  operator: FilterOperator
  values: [ID!]!
}

"""
Indicates how to handle inventory, whether a product should or can go out of stock
"""
enum InventoryPolicy {
  BOTTOMLESS
  DEFAULT
  HOLD
}

"""Indicates whether a variant is in or out of stock"""
enum InventoryStatus {
  INSTOCK
  OUTOFSTOCK
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""The root mutation type for the Demand domain"""
type Mutation {
  """
  Add a new Collection to a DemandHq.
  
  Requires the collection/write permission on the given DemandHq
  """
  createCollection(input: CollectionCreateInput!): Collection!

  """
  Create a Image for a Collection from a file.
  
  Requires the collection/write permission on the given DemandHq
  """
  createCollectionImageFromFile(input: CollectionImageFromFileInput!): CollectionImageFromFileResponse!

  """
  Create a Image for a Collection from a URL.
  
  Requires the collection/write permission on the given DemandHq
  """
  createCollectionImageFromUrl(input: CollectionImageFromUrlInput!): Collection!

  """
  Create Images for a Collection from files.
  
  Requires the collection/write permission on the given DemandHq
  """
  createCollectionImagesFromFiles(inputs: [CollectionImageFromFileInput!]!): CollectionImageFromFilesResponse!

  """
  Create a new CollectionTypeContent.
                  
  Requires the collectiontypecontent/write scope on the associated DemandHq.
  """
  createCollectionTypeContent(input: CollectionTypeContentCreateInput!): CollectionTypeContent!

  """
  Creates a new Customer
                  
  Requires the customer/write scope on the associated DemandHq.
  """
  createCustomer(input: CustomerCreateInput!): Customer

  """
  Creates a new CustomerAddress
                  
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  createCustomerAddress(input: CustomerAddressCreateInput!): CustomerAddress

  """
  Create a new demandHq
              
  Requires demandHq/write permission on the requesting identity
  """
  createDemandHq(input: DemandHqCreateInput!): DemandHq!

  """
  Add a new DemandHqIdentity to a DemandHq (give a user permissions)
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  createDemandHqIdentity(input: DemandHqIdentityCreateInput!): DemandHqIdentity!

  """
  Create a new Nav.
                  
  Requires the "nav/write" permission on the associated DemandHq.
  """
  createNav(input: NavCreateInput!): Nav

  """
  Create an Order (Draft Status).
                  
  Requires the order/write permission on the given DemandHq.
  """
  createOrder(input: OrderCreateInput!): Order!

  """
  Create an OrderItem.
              
  Requires the orderitem/write permission on the associated DemandHq.
  """
  createOrderItem(input: OrderItemCreateInput!): OrderItem!

  """
  Create an OrderTransaction.
              
  Requires the ordertransaction/write permission on the associated DemandHq.
  """
  createOrderTransaction(input: OrderTransactionCreateInput!): OrderTransaction!

  """
  Add a new Page to a DemandHq.
  
  Requires the page/write permission on the given DemandHq
  """
  createPage(input: PageCreateInput!): Page!

  """
  Create an Image for a Page from a file.
  
  Requires the page/write permission on the given DemandHq
  """
  createPageImageFromFile(input: PageImageFromFileInput!): PageImageFromFileResponse!

  """
  Create a Image for a Page from a URL.
  
  Requires the page/write permission on the given DemandHq
  """
  createPageImageFromUrl(input: PageImageFromUrlInput!): Page!

  """
  Create Images for a Page from files.
  
  Requires the page/write permission on the given DemandHq
  """
  createPageImagesFromFiles(inputs: [PageImageFromFileInput!]!): PageImageFromFileResponses!

  """
  Create a new PageTypeContent.
                  
  Requires the pagetypecontent/write scope on the associated DemandHq.
  """
  createPageTypeContent(input: PageTypeContentCreateInput!): PageTypeContent!

  """
  Add a new Product to a DemandHq.
  
  Requires the product/write permission on the given DemandHq
  """
  createProduct(input: ProductCreateInput!): Product!

  """Create a ProductContentItem from a URL"""
  createProductImageFromUrl(input: ProductImageFromUrlInput!): ProductContentItem!

  """Create ProductContentItems from image files"""
  createProductImagesFromFiles(inputs: [ProductImageFromFileInput!]!): ProductImagesFromFilesResponse!

  """Create a new productLocale."""
  createProductLocale(input: ProductLocaleCreateInput!): ProductLocale!

  """
  Create a new Storefront.
      
  Requires the "storefront/write" scope on the associated DemandHq.
  """
  createStorefront(input: StorefrontCreateInput): Storefront

  """
  Create a new variant
              
  Requires variant/write permission on the associated demandHq for the requesting identity
  """
  createVariant(input: VariantCreateInput!): Variant!

  """Create a new VariantSupplierVariant"""
  createVariantSupplierVariant(input: VariantSupplierVariantCreateInput!): VariantSupplierVariant!

  """
  Delete a Collection from a DemandHq.
  
  Requires the collection/write permission on the given DemandHq
  """
  deleteCollection(collectionId: ID!): CollectionDeleteResponse!

  """
  Delete a CollectionContentItem from a Collection.
  
  Requires the collection/write permission on the given DemandHq
  """
  deleteCollectionContentItem(
    """
    If the contentItem is present as a primaryImageUrl or secondaryImageUrl on
    the Collection, also remove it from these fields.
    """
    alsoRemoveImageUrls: Boolean
    collectionId: ID!
    contentItemId: ID!
  ): DeleteCollectionContentItemResponse!

  """
  Delete a CollectionTypeContent.
  
  Requires the collectiontypecontent/write scope on the associated DemandHq.
  """
  deleteCollectionTypeContent(collectionTypeContentId: ID!): CollectionTypeContentDeletedResponse!

  """
  Deletes a Customer
              
  Requires the customer/write scope on the associated DemandHq.
  """
  deleteCustomer(customerId: ID!): DeleteCustomerResponse!

  """
  Deletes a CustomerAddress
              
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  deleteCustomerAddress(customerAddressId: ID!): DeleteCustomerAddressResponse!

  """
  Delete a DemandHqIdentity from a DemandHq (remove a user's permissions)
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  deleteDemandHqIdentity(demandHqId: ID!, identityId: ID!): DemandHqIdentityDeleteResponse

  """
  Delete a Nav.
  
  Requires the "nav/write" permission on the associated DemandHq.
  """
  deleteNav(navId: ID!): DeleteNavResponse!

  """
  Delete a Page from a DemandHq.
  
  Requires the page/write permission on the given DemandHq
  """
  deletePage(pageId: ID!): PageDeleteResponse!

  """
  Delete a PageContentItem from a Page.
  
  Requires the page/write permission on the given DemandHq
  """
  deletePageContentItem(
    """
    If the contentItem is present as a primaryImageUrl or secondaryImageUrl on the Page, also remove it from these fields.
    """
    alsoRemoveImageUrls: Boolean
    contentItemId: ID!
    pageId: ID!
  ): DeletePageContentItemResponse!

  """
  Delete a PageTypeContent.
  
  Requires the pagetypecontent/write scope on the associated DemandHq.
  """
  deletePageTypeContent(pageTypeContentId: ID!): PageTypeContentDeletedResponse!

  """
  Delete a Product from a DemandHq.
  
  Requires the product/write permission on the given DemandHq
  """
  deleteProduct(productId: ID!): ProductDeleteResponse!

  """Delete an existing ProductContentItem"""
  deleteProductContentItem(contentItemId: ID!, productId: ID!): ProductContentItemDeleteResponse!

  """
  Delete a variant
              
  Requires variant/write permission on the associated demandHq for the requesting identity
  """
  deleteVariant(variantId: ID): VariantDeleteResponse!

  """Delete a VariantSupplierVariant"""
  deleteVariantSupplierVariant(supplierVariantId: ID!, variantId: ID!): VariantSupplierVariantDeleteResponse!

  """
  Install an app to a DemandHq (give an app permissions)
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  installApp(appId: ID!, demandHqId: ID!): AppInstallationResponse!

  """
  Place an Order (into Pending Status).
  
  Requires the order/write permission on the given DemandHq.
  """
  placeOrder(orderId: ID!): Order!

  """
  Request access to sell items from a Supplier.
              
  Requires the requesting identity to have the "demandhqsupplier/write" permission on the associated DemandHq.
  """
  requestSupplierAccess(demandHqId: ID!, supplierId: ID!): DemandHqSupplier!

  """
  Update an app's permissions on a DemandHq. This is a no-op if the app's
  requested permissions are the same as the current permissions.
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  updateAppPermissions(appId: ID!, demandHqId: ID!): AppInstallationResponse!

  """
  Update an existing collection.
  
  Requires the collection/write permission on the given DemandHq
  """
  updateCollection(input: CollectionUpdateInput!): Collection!

  """
  Update an existing CollectionTypeContent.
  
  Requires the collectiontypecontent/write scope on the associated DemandHq.
  """
  updateCollectionTypeContent(input: CollectionTypeContentUpdateInput!): CollectionTypeContent!

  """
  Updates an existing Customer
  
  Requires the customer/write scope on the associated DemandHq.
  """
  updateCustomer(input: CustomerUpdateInput!): Customer

  """
  Updates an existing CustomerAddress
  
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  updateCustomerAddress(input: CustomerAddressUpdateInput!): CustomerAddress

  """
  Update an existing demandHq
  
  Requires demandHq/write permission on the requesting identity
  """
  updateDemandHq(input: DemandHqUpdateInput!): DemandHq!

  """
  Update a DemandHqIdentity for a DemandHq (give a user permissions)
  
  Requires the demandHqidentity/write permission on the given DemandHq
  """
  updateDemandHqIdentity(input: DemandHqIdentityUpdateInput!): DemandHqIdentity!

  """
  Update an existing Nav.
  
  Requires the "nav/write" permission on the associated DemandHq.
  """
  updateNav(input: NavUpdateInput!): Nav

  """
  Update an Order.
  
  Requires the order/write permission on the given DemandHq.
  """
  updateOrder(input: OrderUpdateInput!): Order!

  """
  Update an OrderItem.
  
  Requires the orderitem/write permission on the associated DemandHq.
  """
  updateOrderItem(input: OrderItemUpdateInput!): OrderItem!

  """
  Update an existing page.
  
  Requires the page/write permission on the given DemandHq
  """
  updatePage(input: PageUpdateInput!): Page!

  """
  Update an existing PageTypeContent.
  
  Requires the pagetypecontent/write scope on the associated DemandHq.
  """
  updatePageTypeContent(input: PageTypeContentUpdateInput!): PageTypeContent!

  """
  Update an existing product.
  
  Requires the product/write permission on the given DemandHq
  """
  updateProduct(input: ProductUpdateInput!): Product!

  """Update an existing ProductContentItem"""
  updateProductContentItem(input: ProductContentItemUpdateInput!): ProductContentItem!

  """Update an existing productLocale"""
  updateProductLocale(input: ProductLocaleUpdateInput!): ProductLocale!

  """
  Update an existing Storefront.
      
  Requires the "storefront/write" scope on the associated DemandHq.
  """
  updateStorefront(input: StorefrontUpdateInput): Storefront

  """
  Update an existing variant
              
  Requires variant/write permission on the associated demandHq for the requesting identity
  """
  updateVariant(input: VariantUpdateInput!): Variant!

  """
  Bulk update variants
  
  Requires variant/write permission on the associated demandHq for the requesting identity
  Note that if there are Permission or UserInput Errors, the entire group will fail, not partially succeed.
  """
  updateVariants(inputs: [VariantUpdateInput!]): [Variant!]

  """
  Add or Update CollectionContent for an existing Collection.
  
  Requires the collection/write permission on the given DemandHq
  """
  upsertCollectionContent(input: CollectionContentUpsertInput!): CollectionContent!

  """
  Add or Update PageContent for an existing Page.
  
  Requires the page/write permission on the given DemandHq
  """
  upsertPageContent(input: PageContentUpsertInput!): PageContent!

  """
  Upsert storefront nav settings.
                  
  Requires the storefrontnavsettings/write permission on the associated DemandHq.
  """
  upsertStorefrontNavSettings(input: StorefrontNavSettingsUpsertInput!): StorefrontNavSettings!
}

"""
Nav is an item within a navigational heirarchy of some kind, most often viewed as a menu.
"""
type Nav {
  createdAt: Date!
  demandHqId: ID!

  """
  Where this Nav link should lead to. Can be an absolute or relative url. 768 character limit.
  """
  href: String!

  """The label for this Nav, limit 64 characters."""
  label: String!

  """
  This has two primary purposes:
  To make this Nav "lookupable" in combination with linkType.
  To make entities aware they are being referenced. This is done with the
  reserved system linkTypes in combination with entitySlugs (i.e. Collection and
  a collection slug).
  """
  linkSlug: String!

  """
  This can be any string, but certain values have special meaning (like "collection").
  These are restricted to the specified values in NavSettings.
  """
  linkType: String!
  navId: ID!

  """
  A number, representing where this Nav resides in the heirarchy. Immutable, and
  limited to 0 through 6. 0 is the top level, 1 is the second level, etc.
  """
  navLevel: Int!

  """
  A string indicating the purpose of this Nav hierarchy, must match parentNav if applicable. Limit 128 characters.
  """
  navType: String!

  """
  List Child Navs for a nav.
  
  Requires the user to have the nav/read permission on the associated DemandHq.
  """
  navs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): NavConnection!

  """All Navs besides the root (Level 0) have a parentNavId. Immutable."""
  parentNavId: ID

  """
  Where this Nav should be located with respect to other Navs. Need not be sequential or unique.
  """
  position: Int
  storefrontId: ID!
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through Navs"""
type NavConnection {
  edges: [NavEdge]!
  nodes: [Nav]!
  pageInfo: PageInfo!
}

"""The input for creating a Nav."""
input NavCreateInput {
  demandHqId: ID!

  """
  Where this Nav link should lead to. Can be an absolute or relative url. 768 character limit.
  """
  href: String!

  """The label for this Nav, limit 64 characters."""
  label: String!

  """
  This has two primary purposes:
  To make this Nav "lookupable" in combination with linkType.
  To make entities aware they are being referenced. This is done with the
  reserved system linkTypes in combination with entitySlugs (i.e. Collection and
  a collection slug).
  """
  linkSlug: String!

  """
  This can be any string, but certain values have special meaning (like "collection").
  These are restricted to the specified values in NavSettings.
  """
  linkType: String!

  """
  A number, representing where this Nav resides in the heirarchy. Immutable, and
  limited to 0 through 6. 0 is the top level, 1 is the second level, etc.
  """
  navLevel: Int!

  """
  A string indicating the purpose of this Nav hierarchy, must match parentNav if applicable. Limit 128 characters.
  """
  navType: String!

  """All Navs besides the root (Level 0) have a parentNavId. Immutable."""
  parentNavId: ID

  """
  Where this Nav should be located with respect to other Navs. Need not be sequential or unique.
  """
  position: Int
  storefrontId: ID!
}

"""One edge producing one Nav Node"""
type NavEdge {
  node: Nav
}

"""The input for updating a Nav."""
input NavUpdateInput {
  """
  Where this Nav link should lead to. Can be an absolute or relative url. 768 character limit.
  """
  href: String

  """The label for this Nav, limit 64 characters."""
  label: String

  """
  This has two primary purposes:
  To make this Nav "lookupable" in combination with linkType.
  To make entities aware they are being referenced. This is done with the
  reserved system linkTypes in combination with entitySlugs (i.e. Collection and
  a collection slug).
  """
  linkSlug: String

  """
  This can be any string, but certain values have special meaning (like "collection").
  These are restricted to the specified values in NavSettings.
  """
  linkType: String
  navId: ID!

  """
  Where this Nav should be located with respect to other Navs. Need not be sequential or unique.
  """
  position: Int
}

"""
An order is a collection of items that a customer has purchased.
As an order accrues transactions, it changes status until it is eventually complete.
Orders rely on Suppliers to fulfill the OrderItems by creating PurchaseOrderItems (which are then fulfilled).
"""
type Order {
  billingAddress: Address!
  createdAt: Date!
  customerId: ID

  """A note provided by the customer at time of order"""
  customerNote: String
  demandHqId: ID!
  emailAddress: String!

  """
  List the items in an order.
              
  Requires the orderitem/read permission on the associated DemandHq.
  """
  items(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): OrderItemConnection!
  note: String
  orderId: ID!

  """
  A reference to an outside payment gateway, used for tracking transactions. May be an orderID, or a paymentID.
  """
  paymentId: ID
  phoneNumber: String

  """
  ISO Date indicated when an order should be considered complete, closed for some changes, and started to process.
  """
  placedAt: Date
  shippingAddress: Address!

  """
  The status of the order currently, this field is read-only and can change many times over the course of the order
  """
  status: OrderStatus!
  storefrontId: ID

  """
  Get the tags for an order.
  
  Requires the order/read scope on the associated DemandHq.
  """
  tags: OrderTags

  """
  List the transactions in an order.
              
  Requires the ordertransaction/read permission on the associated DemandHq.
  """
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): OrderTransactionConnection!
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through Orders"""
type OrderConnection {
  edges: [OrderEdge]!
  nodes: [Order]!
  pageInfo: PageInfo!
}

"""Input for creating an Order"""
input OrderCreateInput {
  billingAddress: AddressInput!
  customerId: ID

  """A note provided by the customer at time of order"""
  customerNote: String
  demandHqId: ID!
  emailAddress: String!
  note: String

  """
  A reference to an outside payment gateway, used for tracking transactions. May be an orderID, or a paymentID.
  """
  paymentId: ID
  phoneNumber: String
  shippingAddress: AddressInput!
  storefrontId: ID
  tags: [String]
}

"""One edge producing one Order Node"""
type OrderEdge {
  node: Order
}

"""An item in an Order."""
type OrderItem {
  adjustments: [OrderItemAdjustment]
  barcode: String!
  createdAt: Date!
  currency: ResonanceCurrency!
  customProperties: JSON
  deliveryMethod: VariantDeliveryMethod!
  demandHqId: ID!
  discounts: [OrderItemDiscount]
  note: String
  orderId: ID!
  orderItemId: ID!
  productId: ID!
  productTitle: String!
  purchaseOrderItems: [OrderItemPurchaseOrderItem]
  quantity: Int!
  shippingCharges: [OrderItemShippingCharge]
  shippingMethod: ShippingMethod
  sku: String
  status: OrderItemStatus!
  taxes: [OrderItemTax]

  """Price per item, can be multiplied by quantity for total price"""
  unitPrice: Float!
  updatedAt: Date!
  updatedBy: ID!
  variantId: ID!
  variantTitle: String!
  vendor: String!
}

"""
An adjustment to an OrderItem. Adjustments to orders occur for a variety of
reasons, and are only allowed at certain stages of the order process.
"""
type OrderItemAdjustment {
  adjustedAt: Date!

  """The amount of the adjustment."""
  adjustmentAmount: Float!

  """The reason for the adjustment."""
  adjustmentReason: OrderItemAdjustmentReason!

  """The type of adjustment."""
  adjustmentType: OrderItemAdjustmentType!
}

"""Input for OrderItemAdjustment"""
input OrderItemAdjustmentInput {
  adjustedAt: Date!

  """The amount of the adjustment."""
  adjustmentAmount: Float!

  """The reason for the adjustment."""
  adjustmentReason: OrderItemAdjustmentReason!

  """The type of adjustment."""
  adjustmentType: OrderItemAdjustmentType!
}

"""Indicates why an Adjustment occurred."""
enum OrderItemAdjustmentReason {
  CUSTOMER_FOUND_LOWER_PRICE
  CUSTOMER_NO_LONGER_NEEDS
  CUSTOMER_ORDERED_BY_ACCIDENT
  CUSTOMER_OTHER
  CUSTOMER_SHIPPING_TOOK_TOO_LONG
  ITEM_NOT_AS_ADVERTISED
  OTHER
  OUT_OF_STOCK
  SPOT_DISCOUNT
  WRONG_ITEM_SHIPPED
}

"""Indicates how to apply an OrderItemAdjustment."""
enum OrderItemAdjustmentType {
  PRICE
  QUANTITY
}

"""Paginate through OrderItems"""
type OrderItemConnection {
  edges: [OrderItemEdge]!
  nodes: [OrderItem]!
  pageInfo: PageInfo!
}

"""Input for creating an OrderItem"""
input OrderItemCreateInput {
  adjustments: [OrderItemAdjustmentInput]
  barcode: String!
  currency: ResonanceCurrency!
  customProperties: JSON
  deliveryMethod: VariantDeliveryMethod!
  demandHqId: ID!
  discounts: [OrderItemDiscountInput]
  note: String
  orderId: ID!
  productId: ID!
  productTitle: String!
  quantity: Int!
  shippingCharges: [OrderItemShippingChargeInput]
  shippingMethod: ShippingMethod
  sku: String
  taxes: [OrderItemTaxInput]

  """Price per item, can be multiplied by quantity for total price"""
  unitPrice: Float!
  variantId: ID!
  variantTitle: String!
  vendor: String!
}

"""
A discount applied to an OrderItem. Discounts alter pricing of an OrderItem, and may include a coupon code to do so.
"""
type OrderItemDiscount {
  code: String

  """The amount of the discount."""
  discountAmount: Float!

  """The type of discount."""
  discountType: OrderItemDiscountType!
  discountedAt: Date!
}

"""Input for OrderItemDiscount"""
input OrderItemDiscountInput {
  code: String

  """The amount of the discount."""
  discountAmount: Float!

  """The type of discount."""
  discountType: OrderItemDiscountType!
  discountedAt: Date!
}

"""Indicates how a discount should be applied"""
enum OrderItemDiscountType {
  PERCENTAGE
  PRICE
}

"""One edge producing one OrderItem Node"""
type OrderItemEdge {
  node: OrderItem
}

"""A relationship entity between an OrderItem and a PurchaseOrderItem."""
type OrderItemPurchaseOrderItem {
  fulfillments: [PurchaseOrderItemFulfillment]
  orderItemId: ID!
  purchaseOrderItemId: ID!
  quantity: Int!
  status: PurchaseOrderItemStatus!
}

"""A shippingCharge applied to an OrderItem."""
type OrderItemShippingCharge {
  amount: Float!
  title: String
}

"""Create or Update an OrderItemShippingCharge"""
input OrderItemShippingChargeInput {
  amount: Float!
  title: String
}

"""Indicates the status of an OrderItem."""
enum OrderItemStatus {
  ASSIGNED

  """
  Indicates that the OrderItem was assigned, but is no longer needed to be fulfilled.
  """
  CANCELLED

  """Indicates that the OrderItem is fully fulfilled and is now complete."""
  FULFILLED

  """
  Indicates that the OrderItem is ready for processing, and data is complete.
  """
  INITIAL
  PARTIALLY_ASSIGNED

  """Indicates that the OrderItem is in the process of being fulfilled."""
  PARTIALLY_FULFILLED
}

"""A tax applied to an OrderItem."""
type OrderItemTax {
  amount: Float!
  rate: Float!
  title: String!
}

"""Input for OrderItemTax"""
input OrderItemTaxInput {
  amount: Float!
  rate: Float!
  title: String!
}

"""Input for updating an OrderItem"""
input OrderItemUpdateInput {
  adjustments: [OrderItemAdjustmentInput]
  customProperties: JSON
  discounts: [OrderItemDiscountInput]
  note: String
  orderItemId: ID!
  taxes: [OrderItemTaxInput]
}

"""Indicates the lifecycle stage an order is in"""
enum OrderStatus {
  """Order has been authorized, waiting on fulfillment"""
  AUTHORIZED

  """
  Order has been paid, and is now complete. This can also indicate that an order
  was partially or fully refunded, but that process is also complete.
  """
  COMPLETE

  """
  Initial state for an order, during which it can contain invalid or incomplete information
  """
  DRAFT

  """Order has been fulfilled, waiting on payment"""
  FULFILLED

  """
  Order has been partially fulfilled, and paid up for the currently fulfilled items
  """
  PARTIALLY_FULFILLED

  """
  Order has been partially fulfilled, waiting on other fulfillments and for the existing fulfillments payment
  """
  PARTIALLY_FULFILLED_AWAITING_PAYMENT

  """Order has been placed, waiting on authorization"""
  PENDING
}

"""These are the tags associated to the order"""
type OrderTags {
  demandHqId: ID!
  orderId: ID!

  """Get the tags for an order parsed into category, key, and value."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""A transaction in an Order."""
type OrderTransaction {
  amount: Float!
  authorizationCode: String
  authorizationExpiresAt: Date
  createdAt: Date!
  currency: ResonanceCurrency!
  currencyExchangeAdjustment: OrderTransactionCurrencyExchangeAdjustment
  demandHqId: ID!
  errorMessage: String
  gateway: OrderTransactionGateway!
  gatewayMessage: String
  gatewayTransactionId: ID
  orderId: ID!
  orderTransactionId: ID!
  orderTransactionType: OrderTransactionType!
  processedAt: Date
  updatedBy: ID!
}

"""Paginate through OrderTransactions"""
type OrderTransactionConnection {
  edges: [OrderTransactionEdge]!
  nodes: [OrderTransaction]!
  pageInfo: PageInfo!
}

"""Input for creating an OrderTransaction"""
input OrderTransactionCreateInput {
  amount: Float!
  authorizationCode: String
  authorizationExpiresAt: Date
  currency: ResonanceCurrency!
  currencyExchangeAdjustment: OrderTransactionCurrencyExchangeAdjustmentInput
  demandHqId: ID!
  errorMessage: String
  gateway: OrderTransactionGateway!
  gatewayMessage: String
  gatewayTransactionId: ID
  orderId: ID!
  orderTransactionType: OrderTransactionType!
  processedAt: Date
}

"""
If money is accepted in a foreign currency, this object describes amounts and currencies in the Shop's default currency.
"""
type OrderTransactionCurrencyExchangeAdjustment {
  """The amount in the shop's default currency."""
  targetAmount: Float!

  """Shop's default currency."""
  targetCurrency: ResonanceCurrency!
}

"""Input for OrderTransactionCurrencyExchangeAdjustment"""
input OrderTransactionCurrencyExchangeAdjustmentInput {
  """The amount in the shop's default currency."""
  targetAmount: Float!

  """Shop's default currency."""
  targetCurrency: ResonanceCurrency!
}

"""One edge producing one OrderTransaction Node"""
type OrderTransactionEdge {
  node: OrderTransaction
}

"""Indicates which Payment Gateway was used for a Transaction."""
enum OrderTransactionGateway {
  TEST
}

"""Indicates the purpose of a given OrderTransaction."""
enum OrderTransactionType {
  """
  Money that the customer has agreed to pay.
  The authorization period can be between 7 and 30 days (depending on your
  payment service) while a store waits for a payment to be captured.
  """
  AUTHORIZATION

  """
  A transfer of money that was reserved during the authorization of a shop.
  """
  CAPTURE

  """The partial or full return of captured money to the customer."""
  REFUND

  """
  The authorization and capture of a payment performed in one single step.
  """
  SALE

  """The cancellation of a pending authorization or capture."""
  VOID
}

"""Input for updating an Order"""
input OrderUpdateInput {
  billingAddress: AddressInput

  """A note provided by the customer at time of order"""
  customerNote: String
  emailAddress: String
  note: String
  orderId: ID!

  """
  A reference to an outside payment gateway, used for tracking transactions. May be an orderID, or a paymentID.
  """
  paymentId: ID
  phoneNumber: String
  shippingAddress: AddressInput
  tags: [String]
}

"""
A Page is a part of the Demand Domain and represents a page with textual and
image content on it, that has nothing to do with products.
This can range from "About Us" pages to Blog articles. Use the "pageType" field to differentiate.
Pages do not have locales specified, but since everything would be different
anyway, "pageType" can be a composite key with locale in it.
"""
type Page {
  """The author of the page, limit 256 characters."""
  author: String

  """Get the content of the page."""
  content: PageContent

  """
  The ContentItemIds of the Content Items that are associated with this page.
  """
  contentItemIds: [ID!]

  """Get the content items of the page."""
  contentItems: [PageContentItem]
  createdAt: Date!
  demandHqId: ID!

  """A short description of the page, limit 1000 characters."""
  description: String

  """
  Get the description if it exists, or fallback to the excerpt of content for the page.
  """
  descriptionOrExcerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String
  pageId: ID!

  """
  Any string to declare a category of this page, can be used to filter pages, limit 128 characters.
  """
  pageType: String!

  """
  A primary image url for this page, can be generated from a Page ContentItem.
  """
  primaryImageUrl: String

  """
  Returns the primary image URL if exists, otherwise attempts to construct an
  image url from the first (featured) image of the page.  If the primary image
  URL is a CDN URL, it can be passed width and height properties to return a resized image.
  """
  primaryImageUrlWithFallback(
    """The height of the image to return in pixels."""
    height: Int

    """The width of the image to return in pixels."""
    width: Int
  ): String

  """
  ISO format date when the page was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """A secondary image url for this page, often a logo or related item."""
  secondaryImageUrl: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this page. Limit 128 characters."""
  slug: String!

  """The status of the page, can be DRAFT or PUBLISHED."""
  status: DemandEntityStatus!

  """Which storefronts should have access to this page?"""
  storefrontIds: [ID]

  """The subtitle of the page, limit 256 characters."""
  subtitle: String

  """Get the tags of the page."""
  tags: PageTags

  """The title of the page, limit 256 characters."""
  title: String!
  updatedAt: Date!
  updatedBy: ID!
}

"""Paginate through Pages"""
type PageConnectionWithSearch {
  edges: [PageEdge]!
  nodes: [Page]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON

  """
  Values and the number of times they occur for the results of the query. These
  will be the same for every page of a query, and should only be fetched on the first page.
  """
  termAggregations: PageTermAggregations
}

"""This is the actual content of the page"""
type PageContent {
  """
  Get the markdown content of the page as parsed HTML. Do not use this field
  without purifying or sanitizing the HTML in your webapp.
  """
  contentAsHtml: String
  contentAsString: String!
  demandHqId: ID!

  """Get an excerpt of the page content."""
  excerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String
  pageId: ID!
  updatedAt: String
  updatedBy: ID!
}

"""
These are content items that are associated with a page, Images, Videos, etc
"""
type PageContentItem {
  contentExtension: String!
  contentItemId: ID!
  contentKey: String!
  contentType: String!
  demandHqId: ID!
}

"""Upsert page content for an existing Page"""
input PageContentUpsertInput {
  contentAsString: String!
  pageId: ID!
}

"""
Exactly like Page, but no publishedAt or Status (Status is set to DRAFT on create).
"""
input PageCreateInput {
  """The author of the page, limit 256 characters."""
  author: String

  """
  The ContentItemIds of the Content Items that are associated with this page.
  """
  contentItemIds: [ID!]
  demandHqId: ID!

  """A short description of the page, limit 1000 characters."""
  description: String

  """
  Any string to declare a category of this page, can be used to filter pages, limit 128 characters.
  """
  pageType: String!

  """
  A primary image url for this page, can be generated from a Page ContentItem.
  """
  primaryImageUrl: String

  """A secondary image url for this page, often a logo or related item."""
  secondaryImageUrl: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this page. Limit 128 characters."""
  slug: String!

  """Which storefronts should have access to this page?"""
  storefrontIds: [ID]

  """The subtitle of the page, limit 256 characters."""
  subtitle: String
  tags: [String]

  """The title of the page, limit 256 characters."""
  title: String!
}

"""Returned object from deletePage"""
type PageDeleteResponse {
  deletedId: ID!
}

"""One edge producing one Page Node"""
type PageEdge {
  node: Page
}

"""The input for creating an Image for a Page from a file"""
input PageImageFromFileInput {
  demandHqId: ID!
  fileExtension: String!
  fileName: String!
  pageId: ID!
}

"""The original input that errored"""
type PageImageFromFileInputResponse {
  demandHqId: ID!
  fileExtension: String!
  fileName: String!
  pageId: ID!
}

"""Returned object from createPageImageFromFile"""
type PageImageFromFileResponse {
  """The contentItemId of the image"""
  contentItemId: ID!

  """Used while uploading the image"""
  fields: JSON!
  page: Page!

  """Used to upload the image"""
  url: String!
}

"""Returned object from createPageImagesFromFiles"""
type PageImageFromFileResponses {
  errors: [PageImagesFromFilesError!]

  """
  A signed S3 url to upload the image to along with supporting data about the image
  """
  mutationResponses: [PageImageFromFileResponse!]!
}

"""Input object for creating an Image for a Page from a URL"""
input PageImageFromUrlInput {
  demandHqId: ID!
  pageId: ID!
  url: String!
}

"""Returned object for any failed CreatePageImagesFromFiles inputs"""
type PageImagesFromFilesError {
  """The error message"""
  error: String!
  input: PageImageFromFileInputResponse!
}

"""Information on Pagination"""
type PageInfo {
  """
  The cursor to use when paginating forwards (using first/after). Will always be
  populated regardless of if a next page exists.
  """
  endCursor: String

  """
  Whether or not using the endCursor will result in more results. Always
  populated, but will always be false when paginating using last/before.
  """
  hasNextPage: Boolean!

  """
  Whether or not using the startCursor will result in more results. Always
  populated, but will always be false when paginating using first/after.
  """
  hasPreviousPage: Boolean!

  """
  The cursor to use when paginating backwards (using last/before). Will always
  be populated regardless of if a previous page exists
  """
  startCursor: String
}

"""
The number of results to return for each term aggregation. Defaults to 0 for each.
"""
input PageNumberOfTermAggregations {
  authors: Int
  pageTypes: Int
  tags: Int
}

"""Indicates which field to sort by, defaults to CREATED_AT"""
enum PageSortField {
  CREATED_AT
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
}

"""Sort Pages by a field and direction."""
input PageSortInput {
  direction: SortDirection!
  field: PageSortField!
}

"""These are the tags associated to the page"""
type PageTags {
  demandHqId: ID!
  pageId: ID!

  """Get parsed, and optionally filtered, tags for a Page."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""A Map of several fields of Page and term aggregations for each"""
type PageTermAggregations {
  authors: [TermAggregation!]
  pageTypes: [TermAggregation!]
  tags: [TermAggregation!]
}

"""
This holds content specific to a pageType. This is generally used on a page that lists all pages for a pageType.
"""
type PageTypeContent {
  """
  Get the markdown content of the pageTypeContent as parsed HTML. Do not use
  this field without purifying or sanitizing the HTML in your webapp.
  """
  contentAsHtml: String
  contentAsString: String
  createdAt: Date!
  demandHqId: ID!

  """
  A short description of the pageTypeContent, limit 1000 characters. This is
  typically used off of the pageTypeContent page itself.
  """
  description: String

  """
  Get the description if it exists, or fallback to the excerpt of content for the PageTypeContent.
  """
  descriptionOrExcerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String

  """Get an excerpt of the PageTypeContent."""
  excerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String
  pageType: String!
  pageTypeContentId: ID!

  """
  Get the secondary markdown content of the pageTypeContent as parsed HTML. Do
  not use this field without purifying or sanitizing the HTML in your webapp.
  """
  secondaryContentAsHtml: String
  secondaryContentAsString: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String
  storefrontId: ID!

  """The subtitle of the pageTypeContent, limit 256 characters."""
  subtitle: String

  """
  These tags function in the opposite direction of other tags, allowing you to
  choose several to focus on while displaying the content.
  Commonly, these are used to filter or categorize content by providing options that match tags on the content itself.
  """
  tags: PageTypeContentTags

  """The title of the pageTypeContent, limit 256 characters."""
  title: String
  updatedAt: Date!
  updatedBy: ID!
}

"""Pagination object for PageTypeContent."""
type PageTypeContentConnection {
  edges: [PageTypeContentEdge]!
  nodes: [PageTypeContent]!
  pageInfo: PageInfo!
}

"""Input object to create a PageTypeContent."""
input PageTypeContentCreateInput {
  contentAsString: String
  demandHqId: ID!

  """
  A short description of the pageTypeContent, limit 1000 characters. This is
  typically used off of the pageTypeContent page itself.
  """
  description: String
  pageType: String!
  secondaryContentAsString: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String
  storefrontId: ID!

  """The subtitle of the pageTypeContent, limit 256 characters."""
  subtitle: String

  """
  These tags function in the opposite direction of other tags, allowing you to
  choose several to focus on while displaying the content.
  Commonly, these are used to filter or categorize content by providing options that match tags on the content itself.
  """
  tags: PageTypeContentTagsInput

  """The title of the pageTypeContent, limit 256 characters."""
  title: String
}

"""This is the response from a deletePageTypeContent mutation."""
type PageTypeContentDeletedResponse {
  deletedId: String!
}

"""An edge containing a PageTypeContent."""
type PageTypeContentEdge {
  node: PageTypeContent
}

"""
These tags function in the opposite direction of other tags, allowing you to
choose several to focus on while displaying the content.
Commonly, these are used to filter or categorize content by providing options that match tags on the content itself.
"""
type PageTypeContentTags {
  """Get parsed, and optionally filtered, tags for a Page."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String!]
}

"""Input object to update PageTypeContentTags."""
input PageTypeContentTagsInput {
  raw: [String!]
}

"""Input object to update a PageTypeContent."""
input PageTypeContentUpdateInput {
  contentAsString: String

  """
  A short description of the pageTypeContent, limit 1000 characters. This is
  typically used off of the pageTypeContent page itself.
  """
  description: String
  pageTypeContentId: ID!
  secondaryContentAsString: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """The subtitle of the pageTypeContent, limit 256 characters."""
  subtitle: String

  """
  These tags function in the opposite direction of other tags, allowing you to
  choose several to focus on while displaying the content.
  Commonly, these are used to filter or categorize content by providing options that match tags on the content itself.
  """
  tags: PageTypeContentTagsInput

  """The title of the pageTypeContent, limit 256 characters."""
  title: String
}

"""
ID Fields are required, but all other fields are optional, only included fields will be updated.
"""
input PageUpdateInput {
  """The author of the page, limit 256 characters."""
  author: String

  """
  The ContentItemIds of the Content Items that are associated with this page.
  """
  contentItemIds: [ID!]

  """A short description of the page, limit 1000 characters."""
  description: String
  pageId: ID!

  """
  Any string to declare a category of this page, can be used to filter pages, limit 128 characters.
  """
  pageType: String

  """
  A primary image url for this page, can be generated from a Page ContentItem.
  """
  primaryImageUrl: String

  """
  ISO format date when the page was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """A secondary image url for this page, often a logo or related item."""
  secondaryImageUrl: String

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this page. Limit 128 characters."""
  slug: String

  """The status of the page, can be DRAFT or PUBLISHED."""
  status: DemandEntityStatus

  """Which storefronts should have access to this page?"""
  storefrontIds: [ID]

  """The subtitle of the page, limit 256 characters."""
  subtitle: String
  tags: [String]

  """The title of the page, limit 256 characters."""
  title: String
}

"""An up to 3-part tag, comma-separated, that has been parsed"""
type ParsedTag {
  """The category of the tag"""
  category: String

  """The key of the tag"""
  key: String

  """The value of the tag"""
  value: String!
}

"""
A Product is a part of the Demand Domain and represents a the basic information of a product.
Products have many support entities, including variants, which represent SKUs of the product.
"""
type Product {
  """
  Get a productContentItem for a product
  
          Requires productcontentitem/read permission on the requesting identity
  """
  contentItem(contentItemId: ID!): ProductContentItem

  """
  Get a list of productContentItems
  
  Requires productcontentitem/read permission on the DemandHq for the requesting identity
  
  Sorting works differently depending on which filters are used.
  Without any filters, the sort order is by createdAt.
  With a contentType filter, the sort order is by position.
  This means "featuredImage" can be retrieved by using contentType: IMAGE and first: 1.
  """
  contentItems(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    contentType: ProductContentType

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): ProductContentItemConnection
  createdAt: Date!
  demandHqId: ID!

  """
  Get a single productLocale by ResonanceLocaleType
  
      Requires productlocale/read permission on the requesting identity
  """
  locale(localeType: ResonanceLocaleType!): ProductLocale

  """
  The labels for the possible option groups for this product, i.e. "Color", "Size", "Material", etc.
  These will match with labelOptions in Variants.
  """
  optionLabels: [String!]!
  productId: ID!

  """
  Get productMetrics for a Product
  
      Requires product/read permission
  """
  productMetrics: ProductMetrics

  """
  ISO format date when the product was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this product. Limit 128 characters."""
  slug: String!

  """The status of the product, can be DRAFT or PUBLISHED."""
  status: DemandEntityStatus!

  """Which storefronts should have access to this product?"""
  storefrontIds: [ID]

  """Get the tags for this product"""
  tags: ProductTags

  """The title of the product, limit 256 characters."""
  title: String!
  updatedAt: Date!
  updatedBy: ID!

  """
  Get a single variant by VariantId
  
      Requires demandHqvariant/read permission on the requesting identity
  """
  variant(variantId: ID): Variant

  """
  Get a list of variants
  
      Requires demandHqvariant/read permission on the demandHq for the requesting identity
  """
  variants(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): VariantConnection!

  """AKA Brand. Limit 256 characters."""
  vendor: String!
}

"""Paginate through Products"""
type ProductConnectionWithSearch {
  edges: [ProductEdge]!
  nodes: [Product]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON

  """
  Values and the number of times they occur for the results of the query. These
  will be the same for every page of a query, and should only be fetched on the first page.
  """
  termAggregations: ProductTermAggregations
}

"""
This has a many to one relationship with Product, and provides a connection to the CDN items.
"""
type ProductContentItem {
  alt: String!
  category: String
  contentItemId: ID!

  """The key to the file in the CDN"""
  contentKey: String!
  contentType: ProductContentType!
  createdAt: Date!
  demandHqId: ID!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int
  productId: ID!
  updatedAt: Date!
  updatedBy: String!
}

"""Paginate through ProductContentItems"""
type ProductContentItemConnection {
  edges: [ProductContentItemEdge]!
  nodes: [ProductContentItem]!
  pageInfo: PageInfo!
}

"""
The 'id' type for the deleted ProductContentItem returned from the mutation
"""
type ProductContentItemDeleteId {
  contentItemId: ID!
  productId: ID!
}

"""The response type from a ProductContentItem delete mutation"""
type ProductContentItemDeleteResponse {
  deletedId: ProductContentItemDeleteId
}

"""One edge producing one ProductContentItem Node"""
type ProductContentItemEdge {
  node: ProductContentItem
}

"""Input object for updating an existing ProductContentItem Image"""
input ProductContentItemUpdateInput {
  alt: String
  category: String
  contentItemId: ID!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int
  productId: ID!
}

"""Describes what type of content the contentItem is"""
enum ProductContentType {
  IMAGE
  VIDEO
}

"""
Exactly like Product, but no Status (Status is set to DRAFT on create).
"""
input ProductCreateInput {
  demandHqId: ID!

  """
  The labels for the possible option groups for this product, i.e. "Color", "Size", "Material", etc.
  These will match with labelOptions in Variants.
  """
  optionLabels: [String!]!

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this product. Limit 128 characters."""
  slug: String!

  """Which storefronts should have access to this product?"""
  storefrontIds: [ID]
  tags: [String]

  """The title of the product, limit 256 characters."""
  title: String!

  """AKA Brand. Limit 256 characters."""
  vendor: String!
}

"""Returned object from deleteProduct"""
type ProductDeleteResponse {
  deletedId: ID!
}

"""One edge producing one Product Node"""
type ProductEdge {
  node: Product
}

"""Input object for creating a ProductContentItem Image from a file"""
input ProductImageFromFileInput {
  alt: String!
  category: String
  demandHqId: ID!
  fileExtension: String!
  fileName: String!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int
  productId: ID!
}

"""The original input that errored"""
type ProductImageFromFileInputResponse {
  alt: String!
  category: String
  demandHqId: ID!
  fileExtension: String!
  fileName: String!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int
  productId: ID!
}

"""The response object from createProductImageFromFile"""
type ProductImageFromFileResponse {
  contentItem: ProductContentItem!
  fields: JSON!
  url: String!
}

"""Input object for creating a ProductContentItem Image from a URL"""
input ProductImageFromUrlInput {
  alt: String!
  category: String
  demandHqId: ID!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int
  productId: ID!
  url: String!
}

"""Returned object for any failed createProductImagesFromFiles inputs"""
type ProductImagesFromFilesError {
  """The error message"""
  error: String!
  input: ProductImageFromFileInputResponse!
}

"""Returned object from createProductImagesFromFiles"""
type ProductImagesFromFilesResponse {
  errors: [ProductImagesFromFilesError!]

  """
  A signed S3 url to upload the image to along with supporting data about the image
  """
  mutationResponses: [ProductImageFromFileResponse!]!
}

"""
This has a many to one relationship with Product, and provides localized language data for the appropriate fields.
There will often only be one of these, and it should be the one set in defaultLocale for the supplier.
"""
type ProductLocale {
  createdAt: String!
  demandHqId: ID!

  """Can utilize Markdown"""
  description: String

  """Returns the product (productLocale) description as HTML."""
  descriptionAsHTML: String

  """Limited to 5 bullets"""
  featureBullets: [String]
  localeType: ResonanceLocaleType!
  productId: ID!
  updatedAt: String!
  updatedBy: String!
}

"""The necessary fields in order to create a new productLocale"""
input ProductLocaleCreateInput {
  demandHqId: ID!

  """Can utilize Markdown"""
  description: String

  """Limited to 5 bullets"""
  featureBullets: [String]
  localeType: ResonanceLocaleType!
  productId: ID!
}

"""
The necessary fields in order to update a productLocale.
ID fields are required, others are optional, only included fields will be updated.
"""
input ProductLocaleUpdateInput {
  """Can utilize Markdown"""
  description: String

  """Limited to 5 bullets"""
  featureBullets: [String]
  localeType: ResonanceLocaleType!
  productId: ID!
}

"""
Metrics for a product including msrp min/max, price min/max, and discount metrics
"""
type ProductMetrics {
  """This number is mostly useful in tallying other numbers, averages, etc."""
  countOfVariants: Int!
  demandHqId: ID!

  """The maximum discount for all of the variants"""
  discountMaximum: Float!

  """
  The maximum discount for all in stock variants (null if no variants are in stock)
  """
  discountMaximumInStock: Float

  """The minimum discount for all of the variants"""
  discountMinimum: Float!

  """
  The minimum discount for all in stock variants (null if no variants are in stock)
  """
  discountMinimumInStock: Float

  """The maximum discount percentage for all of the variants"""
  discountPercentageMaximum: Float!

  """
  The maximum discount percentage for all in stock variants (null if no variants are in stock)
  """
  discountPercentageMaximumInStock: Float

  """The minimum discount percentage for all of the variants"""
  discountPercentageMinimum: Float!

  """
  The minimum discount percentage for all in stock variants (null if no variants are in stock)
  """
  discountPercentageMinimumInStock: Float

  """In Stock if any Variant inventoryStatus is In Stock"""
  inventoryStatus: InventoryStatus!

  """The maximum MSRP from all of the variants"""
  msrpMaximum: Float!

  """
  The maximum MSRP from all in stock variants (null if no variants are in stock)
  """
  msrpMaximumInStock: Float

  """The minimum MSRP from all of the variants"""
  msrpMinimum: Float!

  """
  The minimum MSRP from all in stock variants (null if no variants are in stock)
  """
  msrpMinimumInStock: Float

  """The maximum price from all of the variants"""
  priceMaximum: Float!

  """
  The maximum price from all in stock variants (null if no variants are in stock)
  """
  priceMaximumInStock: Float

  """The minimum price from all of the variants"""
  priceMinimum: Float!

  """
  The minimum price from all in stock variants (null if no variants are in stock)
  """
  priceMinimumInStock: Float

  """Id of the associated Product"""
  productId: ID!
  updatedAt: String!
}

"""
The number of results to return for each term aggregation. Defaults to 0 for each.
"""
input ProductNumberOfTermAggregations {
  manufacturers: Int
  tags: Int
  vendors: Int
}

"""Indicates which field to sort by, defaults to CREATED_AT"""
enum ProductSortField {
  CREATED_AT
  MSRP
  PRICE
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
  VENDOR
}

"""Sort Products by a field and direction."""
input ProductSortInput {
  direction: SortDirection!
  field: ProductSortField!
}

"""Filter Products using StandardizedColor (Variant)."""
input ProductStandardizedColorFilterInput {
  operator: FilterOperator
  values: [VariantStandardizedColor!]!
}

"""These are the tags associated to the product"""
type ProductTags {
  demandHqId: ID!

  """Get the tags for an product parsed into category, key, and value."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  productId: ID!
  raw: [String]
  updatedAt: Date!
  updatedBy: ID!
}

"""A Map of several fields of Product and term aggregations for each"""
type ProductTermAggregations {
  manufacturers: [TermAggregation!]
  tags: [TermAggregation!]
  vendors: [TermAggregation!]
}

"""
ID Fields are required, but all other fields are optional, only included fields will be updated.
"""
input ProductUpdateInput {
  """
  The labels for the possible option groups for this product, i.e. "Color", "Size", "Material", etc.
  These will match with labelOptions in Variants.
  """
  optionLabels: [String!]
  productId: ID!

  """
  ISO format date when the product was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this product. Limit 128 characters."""
  slug: String

  """The status of the product, can be DRAFT or PUBLISHED."""
  status: DemandEntityStatus

  """Which storefronts should have access to this product?"""
  storefrontIds: [ID]
  tags: [String]

  """The title of the product, limit 256 characters."""
  title: String

  """AKA Brand. Limit 256 characters."""
  vendor: String
}

"""
This type is returned on routes with no permissions attached to protect
Personally Identifiable Information, but still provide minimal data.
Provides a subset of App from the Identity domain.
"""
type PublicApp {
  appClientIds: [ID!]!
  appId: ID!
  appType: AppType!
  description: String
  name: String!
  partnerId: ID!
  requestedScopes: [String]
  status: AppStatus!
}

"""The parent-most entity of the DemandHq Domain"""
type PublicDemandHq {
  demandHqId: ID!
  description: String
  name: String!
}

"""Paginate through PublicDemandHq"""
type PublicDemandHqConnection {
  edges: [PublicDemandHqEdge]!
  nodes: [PublicDemandHq]!
  pageInfo: PageInfo!
}

"""One edge producing one PublicDemandHq Node"""
type PublicDemandHqEdge {
  node: PublicDemandHq
}

"""
This type is returned on routes with no permissions attached to protect
Personally Identifiable Information, but still provide minimal data.
Can be a User or AppClient.
"""
type PublicIdentity {
  displayName: String!

  """A userName or appClientId"""
  identityId: ID!
  identityParentEntityId: ID
}

"""
This type is the extension of DemandHqIdentity's identityParentEntityId into the Public version of the entity,
        and encompasses all possible uses of that field.
        Currently, this is for Apps only.
"""
union PublicIdentityParent = PublicApp

"""The parent-most entity of the Supplier Domain"""
type PublicSupplier {
  """Indicates the vertical the majority of a Supplier's goods are in."""
  category: SupplierCategory
  description: String

  """
  The approximate number of in stock products this Supplier has on a typical basis.
  """
  inStockProducts: Int
  name: String!
  shipFromAddress: Address
  status: SupplierStatus!
  supplierId: ID!

  """
  The top Brands or Vendors this Supplier carries, limit 5 and 256 characters each.
  """
  topVendors: [String!]
}

"""
This is the main entity of the Supplier domain, and is used to represent a product, which is a group of SKUs.
SKUs are represented by SupplierVariants, a child of this entity.
This entity is less frequently updated, it is more likely that SupplyVariant will be updated frequently.
"""
type PublicSupplierProduct {
  """
  Passed along in PurchaseOrders so the Supplier can identify items in their warehouse.
  """
  externalProductId: String!

  """The first image content item, if it exists"""
  featuredImage: PublicSupplierProductContentItem

  """
  The labels for the options of this product, i.e. ["Color", "Size"]
  These will match with the order of the optionValues on the SupplierVariants.
  Must have 1-3, and it should match the number of options in the variants, but there is no validation to do so.
  Set the first optionLabel to "No Option" if you don't want to use options for this product.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionLabels: [String!]!

  """Reference to the Supplier that owns this product."""
  supplierId: ID!
  supplierProductId: ID!
  tags: PublicSupplierProductTags

  """The title of the product."""
  title: String!

  """The brand or manufacturer of the product."""
  vendor: String!
}

"""Paginate through PublicSupplierProducts"""
type PublicSupplierProductConnectionWithSearch {
  edges: [PublicSupplierProductEdge]!
  nodes: [PublicSupplierProduct]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""
This has a many to one relationship with SupplierProduct, and provides a connection to the CDN items.
"""
type PublicSupplierProductContentItem {
  alt: String!
  category: String
  contentItemId: ID!

  """The key to the file in the CDN"""
  contentKey: String!
  contentType: SupplierProductContentType!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int
  supplierId: ID!
  supplierProductId: ID!
}

"""One edge producing one SupplierProduct Node"""
type PublicSupplierProductEdge {
  node: PublicSupplierProduct
}

"""Indicates which field to sort by, defaults to CREATED_AT"""
enum PublicSupplierProductSortField {
  COST
  CREATED_AT
  INVENTORY_QUANTITY
  MSRP
  RECOMMENDED_PRICE
  RELEVANCE
  TITLE
  UPDATED_AT
  VENDOR
}

"""Categories and other groupings that apply to this product."""
type PublicSupplierProductTags {
  raw: [String!]
  supplierId: ID!
  supplierProductId: ID!
}

"""
The public version of SupplierVariant.  Represents a single SKU.  A
SupplierVariant is a child of a SupplierProduct (this is a one-to-many
relationship, where a SupplierProduct has many SupplierVariants).
"""
type PublicSupplierVariant {
  averageShippingCost: Float

  """Associates contentItems with this variant"""
  contentItemIds: [ID]
  cost: Float
  externalVariantId: String!
  featuredImage: PublicSupplierProductContentItem
  handlingCost: SupplierVariantHandlingCost
  inventoryPolicy: PublicSupplierVariantInventoryPolicy!
  inventoryQuantity: Int!
  inventoryStatus: InventoryStatus!

  """
  An array of the option values that make up this variant.
  For example, a product with a color and size option would have two option values,
  one for each of the color and size options, i.e. ["Red", "Small"]
  Must have 1-3, and it should match the number of options in the product, but there is no validation to do so.
  Set this to "No Option" if you don't want to use options for this product and this is the only variant.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionValues: [String!]!
  supplierId: ID!
  supplierProductId: ID!
  supplierVariantId: ID!
  title: String
}

"""Paginate through PublicSupplierVariants"""
type PublicSupplierVariantConnection {
  edges: [PublicSupplierVariantEdge]!
  nodes: [PublicSupplierVariant]!
  pageInfo: PageInfo!
}

"""One edge producing one SupplierProduct Node"""
type PublicSupplierVariantEdge {
  node: PublicSupplierVariant
}

"""
Indicates how to handle inventory, whether a product should or can go out of stock
"""
enum PublicSupplierVariantInventoryPolicy {
  BOTTOMLESS
  DEFAULT
  HOLD
}

"""A fulfillment on a PurchaseOrderItem."""
type PurchaseOrderItemFulfillment {
  fulfilledAt: Date!
  fulfilledQuantity: Int!
  shippingCarrier: String!
  trackingNumber: String!
}

"""Indicates the status of an PurchaseOrderItem (Supply)."""
enum PurchaseOrderItemStatus {
  """
  Indicates that the PurchaseOrderItem was assigned, but is no longer needed to be fulfilled.
  """
  CANCELLED

  """
  Indicates that the PurchaseOrderItem is fully fulfilled and is now complete.
  """
  FULFILLED

  """
  Indicates that the PurchaseOrderItem is ready for processing, and data is complete.
  """
  INITIAL
  PARTIALLY_ASSIGNED

  """
  Indicates that the PurchaseOrderItem is in the process of being fulfilled.
  """
  PARTIALLY_FULFILLED
}

"""The root query type for the Demand domain"""
type Query {
  """Nothing to see here, just a workaround for Apollo Server"""
  _empty: String

  """
  Get a collection by collectionId.
              
  Required collection/read permission on the given DemandHq.
  """
  collection(collectionId: ID!): Collection

  """
  Get a collectionTypeContent by collectionTypeContentId.
                  
  Requires the collectiontypecontent/read scope on the associated DemandHq
  """
  collectionTypeContent(collectionTypeContentId: ID!): CollectionTypeContent

  """
  Get a Customer by their customerId.
              
  Requires the customer/read permission for the associated DemandHq.
  """
  customer(customerId: ID!): Customer

  """
  Get a single demandHq by DemandHqId
  
  Requires demandHq/read permission on the requesting identity
  """
  demandHq(demandHqId: ID!): DemandHq

  """
  Get a filtered list of DemandHqIdentities
  
  All of the filters are optional, but you must include at least one.
  You may receive less demandHqIdentities than you indicate if you do not have
  permission to read part of the result set.
  
  Not all filter combinations are valid, for example you cannot filter by
  - identityId + identityParentEntityId (requires demandHqId)
  - identityType only (requires demandHqId)
  
  Requires demandHqidentity/read permission on the requesting identity for each demandHq requested,
  or you can request your own identities.
  """
  demandHqIdentities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Filter the results to a specific demandHqId. (optional)"""
    demandHqId: ID

    """Returns the first n elements from the list."""
    first: Int

    """
    Filter the results to a specific identityId.
    Use this with your own userName or appClientId in order to see "My DemandHqIdentities".
    You automatically have access to your own DemandHqIdentities.
    """
    identityId: ID

    """Filter the results to a specific identityParentEntityId (optional)"""
    identityParentEntityId: ID

    """Filter the results to a specific identity type (optional)"""
    identityType: DemandHqIdentityType

    """Returns the last n elements from the list."""
    last: Int
  ): DemandHqIdentityConnection!

  """
  Get a single DemandHqIdentity
  
  Requires demandHqidentity/read permission on the requesting identity for the demandHq requested
  """
  demandHqIdentity(demandHqId: ID!, identityId: ID!): DemandHqIdentity

  """
  Get a DemandHqSupplier by its IDs.
              
  Requires the requesting identity to have the "demandhqsupplier/read" permission on the associated DemandHq.
  """
  demandHqSupplier(demandHqId: ID!, supplierId: ID!): DemandHqSupplier

  """See changes that have been made to this Demand Entity"""
  events(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """The DemandHqId to retrieve events for"""
    demandHqId: ID!

    """The entity to retrieve events for, like a VariantId"""
    entityId: ID!

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): DemandEventConnection!

  """
  Get a Nav by its id.
              
  Requires the user to have the nav/read permission on the associated DemandHq.
  """
  nav(navId: ID!): Nav

  """
  Get an order for an orderId.
              
  Requires the order/read scope on the associated DemandHq.
  """
  order(orderId: ID!): Order

  """
  Get a page by pageId.
              
  Required page/read permission on the given DemandHq.
  """
  page(pageId: ID!): Page

  """
  Get a pageTypeContent by pageType.
                  
  Requires the pagetypecontent/read scope on the associated DemandHq
  """
  pageTypeContent(pageTypeContentId: ID!): PageTypeContent

  """
  Get a single product by ID.
              
  Requires the product/read scope on the associated DemandHq.
  """
  product(productId: ID!): Product

  """
  Get productMetrics for a Product by productId
  
      Requires product/read permission
  """
  productMetrics(productId: ID!): ProductMetrics

  """
  Get productMetrics for Products by productIds
  
      Requires product/read permission
  """
  productMetricses(productIds: [ID!]!): [ProductMetrics]

  """List PublicDemandHqs"""
  publicDemandHqs(demandHqIds: [ID!]): PublicDemandHqConnection!

  """Get the expanded PublicSupplier for this DemandHqSupplier"""
  publicSupplierProducts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Filter SupplierProducts using cost ranges."""
    cost: [FloatRangeFilterInput]

    """The ID of the DemandHq requesting the Public Supplier Products"""
    demandHqId: ID!

    """Returns the first n elements from the list."""
    first: Int

    """Filter SupplierProducts using InventoryPolicy (Variant)."""
    inventoryPolicy: [SupplierProductInventoryPolicyFilterInput]
    inventoryStatus: InventoryStatus

    """Returns the last n elements from the list."""
    last: Int

    """Filter SupplierProducts using Manufacturer (VariantSupplement)."""
    manufacturer: [StringFilterInput]

    """Filter SupplierProducts using MSRP ranges."""
    msrp: [FloatRangeFilterInput]

    """
    Query supplierProducts for certain terms. Searches several fields, including
    supplierProduct.tags, supplierProduct.title, supplierProduct.vendor,
    supplierProductLocales.description, supplierProductLocales.featureBullets,
    supplierVariantSupplements.barcode, supplierVariantSupplement.mpn,
    supplierVariantSupplement.sku
    """
    query: String

    """Filter SupplierProducts using recommendedPrice ranges."""
    recommendedPrice: [FloatRangeFilterInput]

    """
    Sort SupplierProducts by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [SupplierProductSortInput]

    """Filter SupplierProducts using StandardizedColor (Variant)."""
    standardizedColor: [SupplierProductStandardizedColorFilterInput]

    """The ID of the Supplier to get products for."""
    supplierId: ID!

    """Filter SupplierProducts using Tags."""
    tags: [StringFilterInput]

    """Filter SupplierProducts using Vendors."""
    vendor: StringFilterInput
  ): PublicSupplierProductConnectionWithSearch

  """
  Get a list of supplierVariants
  
  Requires suppliervariant/read permission on the supplier for the requesting identity
  """
  publicSupplierVariants(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """The ID of the DemandHq requesting the Public Supplier Product"""
    demandHqId: ID!

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """The ID of the Supplier requesting the Public Supplier Product"""
    supplierId: ID!

    """The ID of the SupplierProduct to get variants for."""
    supplierProductId: ID!
  ): PublicSupplierVariantConnection!

  """
  Get a storefront by its storefrontId.
              
  Requires the storefront/read permission on the associated DemandHq.
  """
  storefront(storefrontId: ID!): Storefront

  """
  Retrieve the settings for a storefront's Navs
              
  Requires the storefrontnavsettings/read permission on the associated DemandHq.
  """
  storefrontNavSettings(storefrontId: ID!): StorefrontNavSettings

  """
  Get a single variant by VariantId
  
      Requires demandHqvariant/read permission on the requesting identity
  """
  variant(variantId: ID): Variant

  """
  Get variantMetrics for a Variant by variantId
              
      Requires variant/read permission
  """
  variantMetrics(variantId: ID!): VariantMetrics

  """
  Get variantMetrics for Variants by variantIds
  
      Requires variant/read permission
  """
  variantMetricses(variantIds: [ID!]!): [VariantMetrics]

  """
  Get a single variantSupplierVariant by id (combination of variantId and supplierVariantId)
  """
  variantSupplierVariant(supplierVariantId: ID!, variantId: ID!): VariantSupplierVariant

  """
  Get a list of variantSupplierVariants by ids (combination of variantIds and supplierVariantIds)
  """
  variantSupplierVariants(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
    variantId: ID
    variantSupplierVariantIds: [VariantSupplierVariantIdInput!]
  ): VariantSupplierVariantConnection!

  """
  Get several variants by VariantIds (currently)
  
      Requires demandHqvariant/read permission on the requesting identity for all associated demandHqs
  """
  variants(variantIds: [ID!]!): VariantConnection!
}

"""Used throughout the app to give a currency to price information"""
enum ResonanceCurrency {
  USD
}

"""
Used throughout the app to indicate what language and locality a given text is in
"""
enum ResonanceLocaleType {
  EN_US
}

"""The speed with which this variant gets delivered. Defaults to GROUND."""
enum ShippingMethod {
  GROUND
  OVERNIGHT
  THREE_DAY
  TWO_DAY
}

"""Indicates which direction to sort, defaults to ASC"""
enum SortDirection {
  ASC
  DESC
}

"""
A Storefront represents a customer facing ecommerce website that consumes Resonance Demand Entities
"""
type Storefront {
  """Get an api key for this storefront by identitySlug."""
  apiKey(slug: String!): StorefrontApiKey

  """Get all api keys for this storefront."""
  apiKeys: [StorefrontApiKey]!
  authenticationSettings: StorefrontAuthenticationSettings
  authenticationType: StorefrontAuthenticationType

  """
  Get all collectionTypeContents for a storefront.
              
  Requires the collectiontypecontent/read scope on the associated DemandHq
  """
  collectionTypeContents(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): CollectionTypeContentConnection!
  createdAt: Date!

  """
  Get a Customer by their customerId.
              
  Requires the customer/read permission for the associated DemandHq.
  """
  customer(customerId: ID!): Customer

  """
  Get a list of Customers.
  
  Requires the customer/read permission for the associated DemandHq.
  """
  customers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    customerIds: [ID]

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): CustomerConnectionWithSearch!
  demandHqId: ID!
  description: String
  name: String!

  """
  List Navs for a storefront.
  
  Requires the user to have the nav/read permission on the associated DemandHq.
  """
  navs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int
    href: String
    hrefPrefix: String

    """Returns the last n elements from the list."""
    last: Int
    linkSlug: String
    linkType: String
    navIds: [ID]
    navLevel: Int
    navType: String
  ): NavConnection!

  """
  Get all pageTypeContents for a storefront.
              
  Requires the pagetypecontent/read scope on the associated DemandHq
  """
  pageTypeContents(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): PageTypeContentConnection!
  storefrontId: ID!
  storefrontIdentities: [StorefrontIdentity!]
  updatedAt: Date!
  updatedBy: ID!
  urlDomain: String!
}

"""
The key of the storefront identity, gets base64 encoded and passed in headers with API requests
"""
type StorefrontApiKey {
  key: String!
  slug: String!
}

"""
Based on the authenticationType, these settings can have different shapes, but this type is all encompassing.
"""
type StorefrontAuthenticationSettings {
  """
  Required for authenticationType JWKS. This is the name of the field containing the customerId, normally 'sub'
  """
  externalCustomerIdFieldName: String

  """
  Required for authenticationType COGNITO or JWKS. This indicates the issuer of the JWT.
  """
  issuer: String!

  """
  Required for authenticationType JWKS. This is the URL of the JWKS endpoint.
  """
  jwksUrl: String
}

"""
Necessary fields to set authentication related settings for a Storefront.
"""
input StorefrontAuthenticationSettingsInput {
  """
  Required for authenticationType JWKS. This is the name of the field containing the customerId, normally 'sub'
  """
  externalCustomerIdFieldName: String

  """
  Required for authenticationType COGNITO or JWKS. This indicates the issuer of the JWT.
  """
  issuer: String!

  """
  Required for authenticationType JWKS. This is the URL of the JWKS endpoint.
  """
  jwksUrl: String
}

"""Indicates what type of authentication is used for the storefront."""
enum StorefrontAuthenticationType {
  """Indicates that the storefront uses Cognito for auth."""
  COGNITO

  """Indicates that the storefront uses a JWT that has a JWKS for auth."""
  JWKS
  NONE
}

"""Paginate through Storefronts"""
type StorefrontConnection {
  edges: [StorefrontEdge]!
  nodes: [Storefront]!
  pageInfo: PageInfo!
}

"""Necessary fields to create a storefront."""
input StorefrontCreateInput {
  authenticationSettings: StorefrontAuthenticationSettingsInput
  authenticationType: StorefrontAuthenticationType
  demandHqId: ID!
  description: String
  name: String!
  storefrontIdentities: [StorefrontIdentityInput!]
  urlDomain: String!
}

"""One edge producing one Storefront Node"""
type StorefrontEdge {
  node: Storefront
}

"""
An identity that is associated with a storefront and is assigned scopes
"""
type StorefrontIdentity {
  permissions: StorefrontPermissions!

  """
  Human-readable way to categorize the use of this identity, must be unique to
  this storefront, all lowercase, and contain no spaces, limit 32 characters.
  """
  slug: String!
}

"""Necessary fields to create a Storefront Identity."""
input StorefrontIdentityInput {
  permissions: StorefrontPermissionsInput!

  """
  Human-readable way to categorize the use of this identity, must be unique to
  this storefront, all lowercase, and contain no spaces, limit 32 characters.
  """
  slug: String!
}

"""The settings for a storefront's Navs"""
type StorefrontNavSettings {
  createdAt: Date!
  demandHqId: ID!

  """
  This sets what linkTypes are allowed for Navs in this storefront. Helps correct human error.
  Maximum of 50 types.
  """
  linkTypes: [String]
  storefrontId: ID!
  updatedAt: Date!
  updatedBy: ID!
}

"""The input for upserting a StorefrontNavSettings"""
input StorefrontNavSettingsUpsertInput {
  demandHqId: ID!

  """
  This sets what linkTypes are allowed for Navs in this storefront. Helps correct human error.
  Maximum of 50 types.
  """
  linkTypes: [String]
  storefrontId: ID!
}

"""The permissions of the storefront identity"""
type StorefrontPermissions {
  roles: [StorefrontRole!]!
  scopes: [String!]!
}

"""Necessary fields to set permissions for a Storefront Identity."""
input StorefrontPermissionsInput {
  roles: [StorefrontRole!]!
  scopes: [String!]!
}

"""The roles of a storefront identity"""
enum StorefrontRole {
  CLIENT
  SERVER
}

"""
Necessary fields to update an existing storefront. Only the fields that are not null will be updated.
"""
input StorefrontUpdateInput {
  authenticationSettings: StorefrontAuthenticationSettingsInput
  authenticationType: StorefrontAuthenticationType
  description: String
  name: String
  storefrontId: ID!
  storefrontIdentities: [StorefrontIdentityInput!]
  urlDomain: String
}

"""
Filter using a combination of operator and an array of string values.
            
Special values:
- '#EXISTS#' - Indicates the field should merely exist, and any value is acceptable. (Or, no value should exist for 'NOT').
"""
input StringFilterInput {
  operator: FilterOperator
  values: [String!]!
}

"""Indicates the vertical the majority of a Supplier's goods are in."""
enum SupplierCategory {
  SPORTING_GOODS
}

"""Describes what type of content the entity is"""
enum SupplierProductContentType {
  IMAGE
  VIDEO
}

"""Filter SupplierProducts using InventoryPolicy (Variant)."""
input SupplierProductInventoryPolicyFilterInput {
  operator: FilterOperator
  values: [PublicSupplierVariantInventoryPolicy!]!
}

"""Sort SupplierProducts by a field and direction."""
input SupplierProductSortInput {
  direction: SortDirection!
  field: PublicSupplierProductSortField!
}

"""Filter SupplierProducts using StandardizedColor (Variant)."""
input SupplierProductStandardizedColorFilterInput {
  operator: FilterOperator
  values: [VariantStandardizedColor!]!
}

"""Indication of whether the Supplier is live and accepting orders"""
enum SupplierStatus {
  """Indicates a Supplier's goods are no longer available for retailing."""
  ARCHIVED

  """
  Indicates that a Supplier's goods are not yet available for retailing. Functionally identical to ARCHIVED.
  """
  DRAFT

  """
  Indicates that a Supplier is activated and available, but not in the public Supplier Marketplace.
  """
  PRIVATE

  """
  Indicates that a Supplier is not only activated, but available in the public Supplier Marketplace.
  """
  PUBLIC
}

"""Object to indicate both amount and unit of handling cost."""
type SupplierVariantHandlingCost {
  amount: Float!
  unit: SupplierVariantHandlingCostUnit!
}

"""Indicates what unit the amount is in"""
enum SupplierVariantHandlingCostUnit {
  """The amount is in a currency, i.e. $"""
  CURRENCY

  """The amount is a percentage of the Cost field"""
  PERCENTAGE_OF_COST
}

"""
Indicates the key of the term aggregation, and approximately how many documents it occurs in. 
"""
type TermAggregation {
  docCount: Int!
  key: String!
}

"""
The main item of the Supplier Domain, represents a single SKU of a product
Only the variant level exists, there is no parent product.
"""
type Variant {
  """UPC, ISBN, GTIN, etc."""
  barcode: String!

  """Quantity in one variant (i.e. 12-pack). Must be a positive integer."""
  casePack: Int

  """Associates contentItems with this variant"""
  contentItemIds: [ID]
  createdAt: String!
  deliveryMethod: VariantDeliveryMethod
  demandHqId: ID!
  isTaxable: Boolean

  """Often same as vendor, but not always."""
  manufacturer: String

  """Minimum Advertised Price. Must be a positive number."""
  mapPrice: Float

  """Manufacturer Part Number"""
  mpn: String

  """Manufacturer's Suggested Retail Price. Must be a positive number."""
  msrp: Float

  """
  An array of the option values that make up this variant.
  For example, a product with a color and size option would have two option values,
  one for each of the color and size options, i.e. ["Red", "Small"]
  Must have 1-3, and it should match the number of options in the product, but there is no validation to do so.
  Set this to "No Option" if you don't want to use options for this product and this is the only variant.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionValues: [String!]!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int

  """Price for the defaultCurrency, can be any positive float number value."""
  price: Float!

  """
  Get the product this variant belongs to.
              
  Requires the product/read scope on the associated DemandHq.
  """
  product: Product
  productId: ID!
  shippingDimensions: VariantShippingDimensions

  """Stock Keeping Unit"""
  sku: String
  standardizedColor: VariantStandardizedColor

  """Get the title of this variant (combo of optionValues)"""
  title: String!
  updatedAt: String!
  updatedBy: String!
  variantId: ID!

  """
  Get variantMetrics for a Variant
              
      Requires variant/read permission
  """
  variantMetrics: VariantMetrics

  """
  Get a single variantSupplierVariant for a Variant by the SupplierVariantId
  """
  variantSupplierVariant(supplierVariantId: ID!): VariantSupplierVariant

  """List all variantSupplierVariants for a Variant"""
  variantSupplierVariants(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): VariantSupplierVariantConnection!
  weight: VariantWeight
}

"""Paginate through Variants"""
type VariantConnection {
  edges: [VariantEdge]!
  nodes: [Variant]!
  pageInfo: PageInfo!
}

"""The necessary fields in order to create a new variant"""
input VariantCreateInput {
  """UPC, ISBN, GTIN, etc."""
  barcode: String!

  """Quantity in one variant (i.e. 12-pack). Must be a positive integer."""
  casePack: Int

  """Associates contentItems with this variant"""
  contentItemIds: [ID]
  deliveryMethod: VariantDeliveryMethod
  demandHqId: ID!
  isTaxable: Boolean

  """Often same as vendor, but not always."""
  manufacturer: String

  """Minimum Advertised Price. Must be a positive number."""
  mapPrice: Float

  """Manufacturer Part Number"""
  mpn: String

  """Manufacturer's Suggested Retail Price. Must be a positive number."""
  msrp: Float

  """
  An array of the option values that make up this variant.
  For example, a product with a color and size option would have two option values,
  one for each of the color and size options, i.e. ["Red", "Small"]
  Must have 1-3, and it should match the number of options in the product, but there is no validation to do so.
  Set this to "No Option" if you don't want to use options for this product and this is the only variant.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionValues: [String!]!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int

  """Price for the defaultCurrency, can be any positive float number value."""
  price: Float!
  productId: ID!
  shippingDimensions: VariantShippingDimensionsInput

  """Stock Keeping Unit"""
  sku: String
  standardizedColor: VariantStandardizedColor
  weight: VariantWeightInput
}

"""Response for when deleting a variant"""
type VariantDeleteResponse {
  deletedId: ID!
}

"""How this variant gets delivered. Defaults to SHIPPING."""
enum VariantDeliveryMethod {
  EMAIL
  SHIPPING
}

"""One edge producing one Variant Node"""
type VariantEdge {
  node: Variant
}

"""Indicates what unit the amount is in"""
enum VariantHandlingCost {
  """The amount is in a currency, i.e. $"""
  CURRENCY

  """The amount is a percentage of the Cost field"""
  PERCENTAGE_OF_COST
}

"""
Metrics for a variant, including inventory quantity, status, and supplierVariant counts
"""
type VariantMetrics {
  countOfInStockSupplierVariants: Int!
  countOfSupplierVariants: Int!
  demandHqId: ID!

  """
  This is mostly useful for determining whether a certain quantity can be added
  to the cart. For BOTTOMLESS InventoryPolicy, a value of 10,000,000 is added here.
  """
  inventoryQuantity: Int!

  """If any SupplierVariant is in stock, this is in stock."""
  inventoryStatus: InventoryStatus!

  """Id of the Product parent of the associated Variant"""
  productId: ID!
  updatedAt: String!

  """Id of the associated Variant"""
  variantId: ID!
}

"""Metric or Standard Dimension?"""
enum VariantShippingDimensionUnit {
  CM
  IN
}

"""Object to indicate all three shipping box dimensions and a unit"""
type VariantShippingDimensions {
  height: Float!
  length: Float!
  unit: VariantShippingDimensionUnit!
  width: Float!
}

"""The necessary fields in order to set Shipping Dimensions for a variant"""
input VariantShippingDimensionsInput {
  height: Float!
  length: Float!
  unit: VariantShippingDimensionUnit!
  width: Float!
}

"""Indicates a standardized color for a variant, i.e. Blue for 'Topaz'"""
enum VariantStandardizedColor {
  BEIGE
  BLACK
  BLUE
  BRONZE
  BROWN
  CLEAR
  GOLD
  GRAY
  GREEN
  MULTICOLOR
  OFFWHITE
  ORANGE
  PINK
  PURPLE
  RED
  SILVER
  WHITE
  YELLOW
}

"""
A VariantSupplierVariant has a 1:1 relationship with a SupplierVariant.
VariantSupplierVariants are the Demand window into the SupplierVariant and can
be used to determine inventory and cost as well as for assigning OrderItems.
Each VariantSupplierVariant has a parent Variant,
"""
type VariantSupplierVariant {
  """
  A calculated metric for some kind of average for a common region. Uncommon.
  Must be a positive number.
  """
  averageShippingCost: Float

  """
  COGS, or Cost of Goods Sold for this VariantSupplierVariant
  Must be a positive number.
  """
  cost: Float!
  createdAt: String!
  demandHqId: ID!

  """Additional warehouse handling charge, typically for larger items."""
  handlingCost: VariantSupplierVariantHandlingCost
  inventoryPolicy: InventoryPolicy!
  inventoryQuantity: Int!

  """Id of the Product the parent Variant is associated with"""
  productId: ID!

  """Id of the Supplier for the associated SupplierVariant"""
  supplierId: ID!

  """Id of the SupplierProduct for the associated SupplierVariant"""
  supplierProductId: ID!

  """Id of the SupplierVariant"""
  supplierVariantId: ID!
  updatedAt: String!
  updatedBy: ID!

  """Id of the parent Variant"""
  variantId: ID!
}

"""Paginate through VariantSupplierVariants"""
type VariantSupplierVariantConnection {
  edges: [VariantSupplierVariantEdge]!
  nodes: [VariantSupplierVariant]!
  pageInfo: PageInfo!
}

"""The fields required to create a new VariantSupplierVariant"""
input VariantSupplierVariantCreateInput {
  """
  A calculated metric for some kind of average for a common region. Uncommon.
  Must be a positive number.
  """
  averageShippingCost: Float

  """
  COGS, or Cost of Goods Sold for this VariantSupplierVariant
  Must be a positive number.
  """
  cost: Float!
  demandHqId: ID!

  """Additional warehouse handling charge, typically for larger items."""
  handlingCost: VariantSupplierVariantHandlingCostInput
  inventoryPolicy: InventoryPolicy!
  inventoryQuantity: Int!

  """Id of the Product the parent Variant is associated with"""
  productId: ID!

  """Id of the Supplier for the associated SupplierVariant"""
  supplierId: ID!

  """Id of the SupplierProduct for the associated SupplierVariant"""
  supplierProductId: ID!

  """Id of the SupplierVariant"""
  supplierVariantId: ID!

  """Id of the parent Variant"""
  variantId: ID!
}

"""Response from deleting a VariantSupplierVariant"""
type VariantSupplierVariantDeleteResponse {
  deletedId: VariantSupplierVariantId!
}

"""One Edge producing one VariantSupplierVariant Node"""
type VariantSupplierVariantEdge {
  node: VariantSupplierVariant!
}

"""Object to indicate both amount and unit of handling cost."""
type VariantSupplierVariantHandlingCost {
  """The amount in currency or as a percentage of the cost"""
  amount: Float!

  """The unit of the amount - currency or percentage of cost"""
  unit: VariantHandlingCost!
}

"""Input object to indicate both amount and unit of handling cost."""
input VariantSupplierVariantHandlingCostInput {
  """The amount in currency or as a percentage of the cost"""
  amount: Float!

  """The unit of the amount - currency or percentage of cost"""
  unit: VariantHandlingCost!
}

"""
Id of a VariantSupplierVariant is a combination of a variantId and a supplierVariantId
"""
type VariantSupplierVariantId {
  supplierVariantId: ID!
  variantId: ID!
}

"""
Id of a VariantSupplierVariant is a combination of a variantId and a supplierVariantId
"""
input VariantSupplierVariantIdInput {
  supplierVariantId: ID!
  variantId: ID!
}

"""The necessary fields in order to update an existing variant"""
input VariantUpdateInput {
  """UPC, ISBN, GTIN, etc."""
  barcode: String

  """Quantity in one variant (i.e. 12-pack). Must be a positive integer."""
  casePack: Int

  """Associates contentItems with this variant"""
  contentItemIds: [ID]
  deliveryMethod: VariantDeliveryMethod
  isTaxable: Boolean

  """Often same as vendor, but not always."""
  manufacturer: String

  """Minimum Advertised Price. Must be a positive number."""
  mapPrice: Float

  """Manufacturer Part Number"""
  mpn: String

  """Manufacturer's Suggested Retail Price. Must be a positive number."""
  msrp: Float

  """
  An array of the option values that make up this variant.
  For example, a product with a color and size option would have two option values,
  one for each of the color and size options, i.e. ["Red", "Small"]
  Must have 1-3, and it should match the number of options in the product, but there is no validation to do so.
  Set this to "No Option" if you don't want to use options for this product and this is the only variant.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionValues: [String!]

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int

  """Price for the defaultCurrency, can be any positive float number value."""
  price: Float
  shippingDimensions: VariantShippingDimensionsInput

  """Stock Keeping Unit"""
  sku: String
  standardizedColor: VariantStandardizedColor
  variantId: ID!
  weight: VariantWeightInput
}

"""Object to indicate both amount and unit of weight."""
type VariantWeight {
  amount: Float!
  unit: VariantWeightUnit!
}

"""The necessary fields in order to set Weight for a variant"""
input VariantWeightInput {
  amount: Float!
  unit: VariantWeightUnit!
}

"""Metric or Standard Weight?"""
enum VariantWeightUnit {
  GRAMS
  LBS
}
