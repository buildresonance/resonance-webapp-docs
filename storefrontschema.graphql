"""
A cart is a temporary container for products that a customer or anonymous user wants to buy
"""
type Cart {
  cartItems: [CartItem]
  cartType: CartType!
  demandHqId: ID!
  externalCustomerOrDeviceId: String!
  savedForLaterItems: [SavedForLaterItem]
  storefrontId: ID!
  updatedAt: Date!
}

"""Input for adding or updating items in a cart or savedForLater"""
input CartAddOrUpdateItemsInput {
  cartItems: [CartItemInput]
  savedForLaterItems: [SavedForLaterItemInput]
}

"""This is an item in the actual cart, ready for purchase."""
type CartItem {
  customProperties: JSON
  quantity: Int!

  """
  The variant that this cart item is associated with.
              
  Requires publicvariant/read permission on the requesting identity.
  """
  variant: PublicVariant
  variantId: ID!
}

"""This input type is used to add or update items in the cart."""
input CartItemInput {
  customProperties: JSON
  quantity: Int!
  variantId: ID!
}

"""Input for removing items from a cart or savedForLater"""
input CartRemoveItemsInput {
  cartItems: [ID!]
  savedForLaterItems: [ID!]
}

"""Indicates the type of cart"""
enum CartType {
  """Indicates that the cart is for a logged in customer"""
  CUSTOMER

  """Indicates this cart is anonymous and tied to a device"""
  DEVICE
}

"""This is the actual content of the collection"""
type CollectionContent {
  collectionId: ID!

  """Get the markdown content of the collection as parsed HTML."""
  contentAsHtml: String
  contentAsString: String!

  """Get the secondary markdown content of the collection as parsed HTML."""
  secondaryContentAsHtml: String
  secondaryContentAsString: String
  updatedAt: String
}

"""These are the tags associated to the collection"""
type CollectionTags {
  """Get parsed, and optionally filtered, tags for a Collection."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
}

"""
A customer of a given Storefront is a user who places orders on the Storefront
"""
type Customer {
  """
  Get a CustomerAddress by their customerAddressId.
  
  Requires the publiccustomeraddress/read permission.
  """
  customerAddress(customerAddressId: ID!): CustomerAddress

  """
  Get a list of CustomerAddresses.
  
  Requires the publiccustomeraddress/read permission.
  """
  customerAddresses(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    customerAddressIds: [ID!]

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): CustomerAddressConnection!
  customerId: ID!

  """
  Get the default billing address for a customer.
  
  Requires the publiccustomeraddress/read permission.
  """
  defaultBillingAddress: CustomerAddress

  """
  The CustomerAddressId for the default billing address for this Customer
  """
  defaultBillingAddressId: ID

  """
  Get the default shipping address for a customer.
  
  Requires the publiccustomeraddress/read permission.
  """
  defaultShippingAddress: CustomerAddress

  """
  The CustomerAddressId for the default shipping address for this Customer
  """
  defaultShippingAddressId: ID
  demandHqId: ID!

  """
  The email address associated with the Customer, must be unique to the storefront, limit 256 characters
  """
  emailAddress: String!
  emailMarketingConsent: CustomerMarketingConsent

  """
  Reference to the storefront's customer authentication system. Limit 256 characters.
  This field is required if this customer is going to access any authenticated data (like their orders).
  """
  externalCustomerId: ID

  """The first name of the Customer, limit 256 characters"""
  firstName: String

  """The last name of the Customer, limit 256 characters"""
  lastName: String

  """
  Must be unique to the Storefront. Limit 64 characters. Format +11231231234
  """
  phoneNumber: String
  smsMarketingConsent: CustomerMarketingConsent
  storefrontId: ID!

  """Get the tags of the customer."""
  tags: CustomerTags
}

"""
A customerAddress is an Address entity that is associated with a customer
"""
type CustomerAddress {
  """The city of the address"""
  city: String!

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String!
  customerAddressId: ID!
  customerId: ID!
  demandHqId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String!

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String!

  """The state of the address"""
  state: String!
  storefrontId: ID!

  """The first line of the street address"""
  streetAddress1: String!

  """The second line of the street address"""
  streetAddress2: String
}

"""Paginate through CustomerAddresses"""
type CustomerAddressConnection {
  edges: [CustomerAddressEdge]!
  nodes: [CustomerAddress]!
  pageInfo: PageInfo!
}

"""Input for creating a CustomerAddress"""
input CustomerAddressCreateInput {
  """The city of the address"""
  city: String!

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String!
  customerId: ID!
  demandHqId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String!

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String!

  """The state of the address"""
  state: String!
  storefrontId: ID!

  """The first line of the street address"""
  streetAddress1: String!

  """The second line of the street address"""
  streetAddress2: String
}

"""One edge producing one CustomerAddress Node"""
type CustomerAddressEdge {
  node: CustomerAddress
}

"""Input for updating a CustomerAddress"""
input CustomerAddressUpdateInput {
  """The city of the address"""
  city: String

  """The company associated with the address"""
  company: String

  """The country of the address"""
  country: String
  customerAddressId: ID!

  """The name associated with the address, i.e. the Person in the household"""
  name: String

  """The phone number of the address. Format +11231231234"""
  phoneNumber: String

  """The zip or postal code of the address"""
  postalCode: String

  """The state of the address"""
  state: String

  """The first line of the street address"""
  streetAddress1: String

  """The second line of the street address"""
  streetAddress2: String
}

"""Details about the Customer's marketing consent"""
type CustomerMarketingConsent {
  """The level at which the Customer has consented to marketing"""
  consentLevel: CustomerMarketingConsentLevel!

  """The date the associated Customer agreed to the marketing consent"""
  consentedAt: Date!
  hasConsented: Boolean!

  """Optional field to store where consent was sourced from"""
  source: String
}

"""Input for updating a Customer's marketing consent"""
input CustomerMarketingConsentInput {
  """The level at which the Customer has consented to marketing"""
  consentLevel: CustomerMarketingConsentLevel!

  """The date the associated Customer agreed to the marketing consent"""
  consentedAt: Date!
  hasConsented: Boolean!

  """Optional field to store where consent was sourced from"""
  source: String
}

"""The level at which the Customer has opted-in to Marketing."""
enum CustomerMarketingConsentLevel {
  """Level 3"""
  CONFIRMED_OPT_IN

  """Level 1"""
  SINGLE_OPT_IN

  """Level 2"""
  SINGLE_OPT_IN_WITH_NOTIFICATION
  UNKNOWN
}

"""These are the tags associated to the Customer"""
type CustomerTags {
  """Get parsed, and optionally filtered, tags for a Customer."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
}

"""Input for updating a Customer"""
input CustomerUpdateInput {
  customerId: ID!

  """
  The CustomerAddressId for the default billing address for this Customer
  """
  defaultBillingAddressId: ID

  """
  The CustomerAddressId for the default shipping address for this Customer
  """
  defaultShippingAddressId: ID

  """
  The email address associated with the Customer, must be unique to the storefront, limit 256 characters
  """
  emailAddress: String
  emailMarketingConsent: CustomerMarketingConsentInput

  """The first name of the Customer, limit 256 characters"""
  firstName: String

  """The last name of the Customer, limit 256 characters"""
  lastName: String

  """
  Must be unique to the Storefront. Limit 64 characters. Format +11231231234
  """
  phoneNumber: String
  smsMarketingConsent: CustomerMarketingConsentInput
}

"""A date in ISO 8601 format"""
scalar Date

"""Returned object from deleteCustomerAddress"""
type DeleteCustomerAddressResponse {
  """The customerAddressId of the customerAddress that was deleted."""
  deletedId: ID!
}

"""Indicates how a filter should behave, defaults to OR"""
enum FilterOperator {
  AND
  NOT
  OR
}

"""
Filter using a min/max number range, in combination these function like an 'Any' filter.
"""
input FloatRangeFilterInput {
  max: Float!
  min: Float!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""The root mutation type for the Demand domain"""
type Mutation {
  """
  Add, Update, or Remove Items from a Customer Cart or SavedForLater.
  
  Requires the publiccart/write scope and a valid customer authentication token.
  """
  changeCustomerCart(
    """
    The items to add or update for the cart or savedForLater. Either
    addOrUpdateItems or removeItems must be provided, and both can be provided.
    """
    addOrUpdateItems: CartAddOrUpdateItemsInput
    customerToken: String!

    """
    The items to add or update to savedForLater. Either addOrUpdateItems or
    removeItems must be provided, and both can be provided.
    """
    removeItems: CartRemoveItemsInput
  ): Cart!

  """
  Add, Update, or Remove Items from a Device Cart or SavedForLater.
  
  Requires the publiccart/write scope.
  """
  changeDeviceCart(
    """
    The items to add or update for the cart or savedForLater. Either
    addOrUpdateItems or removeItems must be provided, and both can be provided.
    """
    addOrUpdateItems: CartAddOrUpdateItemsInput
    deviceId: String!

    """
    The items to add or update to savedForLater. Either addOrUpdateItems or
    removeItems must be provided, and both can be provided.
    """
    removeItems: CartRemoveItemsInput
  ): Cart!

  """
  Creates a new CustomerAddress
  
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  createCustomerAddress(customerToken: String!, input: CustomerAddressCreateInput!): CustomerAddress

  """
  Deletes a CustomerAddress
  
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  deleteCustomerAddress(customerAddressId: ID!, customerToken: String!): DeleteCustomerAddressResponse!

  """
  Merge a device cart into a customer cart. This is primarily done when an anonymous user logs in.
  The device cart will have its items added to the customer cart and then have
  its cartItems cleared. The new customer cart will be returned.
  
  Requires the publiccart/write scope and a valid customer authentication token.
  """
  mergeDeviceCartIntoCustomerCart(customerToken: String!, deviceId: String!): Cart!

  """
  Update a Customer.
  
  Requires the publiccustomer/write scope and a valid customer authentication token.
  """
  updateCustomer(customerToken: String!, input: CustomerUpdateInput): Customer!

  """
  Updates an existing CustomerAddress
  
  Requires the customeraddress/write scope on the associated DemandHq.
  """
  updateCustomerAddress(customerToken: String!, input: CustomerAddressUpdateInput!): CustomerAddress
}

"""This is the actual content of the page"""
type PageContent {
  """Get the markdown content of the page as parsed HTML."""
  contentAsHtml: String
  contentAsString: String!

  """Get an excerpt of the page content."""
  excerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String
  pageId: ID!
  updatedAt: String
}

"""Information on Pagination"""
type PageInfo {
  """
  The cursor to use when paginating forwards (using first/after). Will always be
  populated regardless of if a next page exists.
  """
  endCursor: String

  """
  Whether or not using the endCursor will result in more results. Always
  populated, but will always be false when paginating using last/before.
  """
  hasNextPage: Boolean!

  """
  Whether or not using the startCursor will result in more results. Always
  populated, but will always be false when paginating using first/after.
  """
  hasPreviousPage: Boolean!

  """
  The cursor to use when paginating backwards (using last/before). Will always
  be populated regardless of if a previous page exists
  """
  startCursor: String
}

"""Indicates which field to sort by"""
enum PageSortField {
  PUBLISHED_AT
  RELEVANCE
  TITLE
}

"""Sort Pages by a field and direction."""
input PageSortInput {
  direction: SortDirection!
  field: PageSortField!
}

"""These are the tags associated to the page"""
type PageTags {
  """Get parsed, and optionally filtered, tags for a Page."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
}

"""A Map of several fields of Page and term aggregations for each"""
type PageTermAggregations {
  authors: [TermAggregation!]
  pageTypes: [TermAggregation!]
  tags: [TermAggregation!]
}

"""An up to 3-part tag, comma-separated, that has been parsed"""
type ParsedTag {
  """The category of the tag"""
  category: String

  """The key of the tag"""
  key: String

  """The value of the tag"""
  value: String!
}

"""Indicates which field to sort by, defaults to CREATED_AT"""
enum ProductSortField {
  CREATED_AT
  MSRP
  PRICE
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
  VENDOR
}

"""Sort Products by a field and direction."""
input ProductSortInput {
  direction: SortDirection!
  field: ProductSortField!
}

"""Filter Products using StandardizedColor (Variant)."""
input ProductStandardizedColorFilterInput {
  operator: FilterOperator
  values: [VariantStandardizedColor!]!
}

"""These are the tags associated to the product"""
type ProductTags {
  """Get parsed, and optionally filtered, tags for a Product."""
  parsed(
    """Optionally filter tags by category."""
    category: String

    """
    Optionally filter tags by key. If category is not provided, but key is, category must be null to be returned.
    """
    key: String
  ): [ParsedTag]
  raw: [String]
}

"""A Map of several fields of Product and term aggregations for each"""
type ProductTermAggregations {
  manufacturers: [TermAggregation!]
  tags: [TermAggregation!]
  vendors: [TermAggregation!]
}

"""
A Collection is a group of products, what may often be referred to as a "Category Page" of some variety.
In reality, a collection is far more flexible and can be used to represent any
product grouping, and the collectionType can help differentiate between them.
"""
type PublicCollection {
  collectionId: ID!

  """
  Any string to declare a category of this collection, can be used to filter collections, limit 128 characters.
  """
  collectionType: String!

  """Get the content of the collection."""
  content: CollectionContent
  demandHqId: ID!

  """A short description of the collection, limit 1000 characters."""
  description: String

  """
  This can be used to pin certain products to the top of a collection when using certain sorts.
  Max number of products is 20.
  """
  featuredProductIds: [ID]

  """
  A primary image url for this collection, can be generated from a Collection ContentItem.
  """
  primaryImageUrl: String

  """
  Paginate through products in a collection.
  
  Requires the publicproduct/read scope.
  """
  products(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Optionally filter by manufacturer."""
    manufacturer: [StringFilterInput]

    """Optionally filter by msrp."""
    msrp: FloatRangeFilterInput

    """Optionally filter by price."""
    price: FloatRangeFilterInput

    """
    Query products for certain terms. Searches several fields, including
    product.tags, product.title, product.vendor, productLocales.description,
    productLocales.featureBullets, variant.barcode, variant.mpn, variant.sku
    """
    query: String

    """Filter Products using slugs"""
    slugs: [String]

    """
    Sort Products by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [ProductSortInput]

    """Optionally filter by standardized color."""
    standardizedColor: [ProductStandardizedColorFilterInput]

    """Optionally filter by tags."""
    tags: [StringFilterInput]

    """Optionally filter by vendor."""
    vendor: StringFilterInput
  ): PublicProductConnectionWithSearch!

  """
  ISO format date when the collection was published. Note that ensuing updates
  with status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """Description specific for SEO purposes, limit 170 characters."""
  seoDescription: String

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this collection. Limit 128 characters."""
  slug: String!

  """The subtitle of the collection, limit 256 characters."""
  subtitle: String

  """Get the tags of the collection."""
  tags: CollectionTags

  """The title of the collection, limit 256 characters."""
  title: String!
}

"""Paginate through PublicCollections"""
type PublicCollectionConnectionWithSearch {
  edges: [PublicCollectionEdge]!
  nodes: [PublicCollection]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""One edge producing one PublicCollection Node"""
type PublicCollectionEdge {
  node: PublicCollection
}

"""
Nav is an item within a navigational heirarchy of some kind, most often viewed as a menu.
"""
type PublicNav {
  demandHqId: ID!

  """
  Where this Nav link should lead to. Can be an absolute or relative url. 768 character limit.
  """
  href: String!

  """The label for this Nav, limit 64 characters."""
  label: String!

  """
  This has two primary purposes:
  To make this Nav "lookupable" in combination with linkType.
  To make entities aware they are being referenced. This is done with the
  reserved system linkTypes in combination with entitySlugs (i.e. Collection and
  a collection slug).
  """
  linkSlug: String!

  """
  This can be any string, but certain values have special meaning (like "collection").
  These are restricted to the specified values in NavSettings.
  """
  linkType: String!
  navId: ID!

  """
  A number, representing where this Nav resides in the heirarchy. Immutable, and
  limited to 0 through 6. 0 is the top level, 1 is the second level, etc.
  """
  navLevel: Int!

  """
  A string indicating the purpose of this Nav hierarchy, must match parentNav if applicable. Limit 128 characters.
  """
  navType: String!

  """
  List Child Navs for a Nav.
              
  Requires the publicnav/read permission.
  """
  navs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): PublicNavConnection!

  """All Navs besides the root (Level 0) have a parentNavId. Immutable."""
  parentNavId: ID

  """
  Where this Nav should be located with respect to other Navs. Need not be sequential or unique.
  """
  position: Int
  storefrontId: ID!
}

"""Paginate through PublicNavs"""
type PublicNavConnection {
  edges: [PublicNavEdge]!
  nodes: [PublicNav]!
  pageInfo: PageInfo!
}

"""One edge producing one Nav Node"""
type PublicNavEdge {
  node: PublicNav
}

"""
A Page is a part of the Demand Domain and represents a page with textual and
image content on it, that has nothing to do with products.
This can range from "About Us" pages to Blog articles. Use the "pageType" field to differentiate.
Pages do not have locales specified, but since everything would be different
anyway, "pageType" can be a composite key with locale in it.
"""
type PublicPage {
  """The author of the page, limit 256 characters."""
  author: String

  """Get the content of the page."""
  content: PageContent
  demandHqId: ID!

  """A short description of the page, limit 1000 characters."""
  description: String

  """
  Get the description if it exists, or fallback to the content excerpt for the page.
  """
  descriptionOrExcerpt(
    """The number of characters to return, defaults to 200."""
    numberOfCharacters: Int
  ): String
  pageId: ID!

  """
  Any string to declare a category of this page, can be used to filter pages, limit 128 characters.
  """
  pageType: String!

  """
  A primary image url for this page, can be generated from a Page ContentItem.
  """
  primaryImageUrl: String

  """
  ISO format date when the page was published. Note that ensuing updates with
  status set to PUBLISHED will republish and re-set this date.
  """
  publishedAt: Date

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this page. Limit 128 characters."""
  slug: String!

  """The subtitle of the page, limit 256 characters."""
  subtitle: String

  """Get the tags of the page."""
  tags: PageTags

  """The title of the page, limit 256 characters."""
  title: String!
}

"""Paginate through PublicPages"""
type PublicPageConnectionWithSearch {
  edges: [PublicPageEdge]!
  nodes: [PublicPage]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""One edge producing one PublicPage Node"""
type PublicPageEdge {
  node: PublicPage
}

"""
A Product is a part of the Demand Domain and represents a the basic information of a product.
Products have many support entities, including variants, which represent SKUs of the product.
"""
type PublicProduct {
  demandHqId: ID!

  """
  Get a single productLocale by ResonanceLocaleType.
              
  Requires the "publicproductlocale/read" permission.
  """
  locale: PublicProductLocale

  """
  The labels for the possible option groups for this product, i.e. "Color", "Size", "Material", etc.
  These will match with labelOptions in Variants.
  """
  optionLabels: [String!]!

  """A short description of the product, limit 1000 characters."""
  productId: ID!

  """ISO format date when the product was published."""
  publishedAt: Date

  """Title specific for SEO purposes, limit 256 characters."""
  seoTitle: String

  """Slug for the URL for this product. Limit 128 characters."""
  slug: String!

  """Get the tags of the product."""
  tags: ProductTags

  """The title of the product, limit 256 characters."""
  title: String!

  """
  Get a single variant by VariantId
  
  Requires publicvariant/read permission on the requesting identity.
  """
  variant(variantId: ID): PublicVariant

  """
  Get a list of variants
  
  Requires publicvariant/read permission on the demandHq for the requesting identity.
  """
  variants(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): PublicVariantConnection!

  """The brand of the product, limit 256 characters."""
  vendor: String!
}

"""Paginate through PublicProducts"""
type PublicProductConnectionWithSearch {
  edges: [PublicProductEdge]!
  nodes: [PublicProduct]!
  pageInfo: PageInfo!

  """
  This is an object with terms in the query as keys, and a suggestion for that
  term as the value. This is often referred to as 'Did you mean?'
  """
  querySuggestions: JSON
}

"""One edge producing one PublicProduct Node"""
type PublicProductEdge {
  node: PublicProduct
}

"""
This has a many to one relationship with Product, and provides localized language data for the appropriate fields.
There will often only be one of these, and it should be the one set in defaultLocale for the supplier.
"""
type PublicProductLocale {
  demandHqId: ID!
  description: String

  """Limited to 5 bullets"""
  featureBullets: [String]
  localeType: ResonanceLocaleType!
  productId: ID!
}

"""
A Storefront is the parent-most entity in the Storefront API, and represents the entire site.
"""
type PublicStorefront {
  demandHqId: ID!
  description: String
  name: String!
  storefrontId: ID!
  urlDomain: String!
}

"""
This is the child entity to a Product, and is a variation, such as a color, size, etc.
"""
type PublicVariant {
  """UPC, ISBN, GTIN, etc."""
  barcode: String!

  """Quantity in one variant (i.e. 12-pack). Must be a positive integer."""
  casePack: Int

  """Associates contentItems with this variant"""
  contentItemIds: [ID]
  demandHqId: ID!
  isTaxable: Boolean

  """Often same as vendor, but not always."""
  manufacturer: String

  """Minimum Advertised Price. Must be a positive number."""
  mapPrice: Float

  """Manufacturer Part Number"""
  mpn: String

  """Manufacturer's Suggested Retail Price. Must be a positive number."""
  msrp: Float

  """
  An array of the option values that make up this variant.
  For example, a product with a color and size option would have two option values,
  one for each of the color and size options, i.e. ["Red", "Small"]
  
  Must have 1-3, and it should match the number of options in the product, but there is no validation to do so.
  
  Set this to "No Option" if you don't want to use options for this product and this is the only variant.
  See https://docs.buildresonance.com/concepts/products/#no-option-products for more info.
  """
  optionValues: [String!]!

  """
  Used to determine what order the content comes out in.
  Positive Integers are allowed, up to 9,999,999,999, and it does not have to be unique or sequential.
  """
  position: Int

  """Price for the defaultCurrency, can be any positive float number value."""
  price: Float!

  """
  Get the product associated with the variant.
              
  Requires the publicproduct/read scope.
  """
  product: PublicProduct
  productId: ID!
  shippingDimensions: VariantShippingDimensions

  """Stock Keeping Unit"""
  sku: String
  standardizedColor: VariantStandardizedColor

  """Get the title of this variant (combo of optionValues)"""
  title: String!
  variantId: ID!
  weight: VariantWeight
}

"""Paginate through Variants"""
type PublicVariantConnection {
  edges: [PublicVariantEdge]!
  nodes: [PublicVariant]!
  pageInfo: PageInfo!
}

"""One edge producing one Variant Node"""
type PublicVariantEdge {
  node: PublicVariant
}

"""The root query type for the Demand domain"""
type Query {
  """Nothing to see here, just a workaround for Apollo Server"""
  _empty: String

  """
  Get a collection by its slug.
  
  Requires the publiccollection/read scope.
  """
  collection(slug: String!): PublicCollection

  """
  List collections for a Storefront with optional filters.
              
  Requires the publiccollection/read scope.
  """
  collections(
    """Filter Collections using slugs"""
    slugs: [String]
  ): PublicCollectionConnectionWithSearch!

  """
  Get a Customer for a customer authentication token.
              
  Requires the publiccustomer/read scope and a valid customer authentication token.
  """
  customer(customerToken: String!): Customer

  """
  The cart for the currently logged in customer. Will create a blank cart if one does not exist, never returns null.
              
  Requires the publiccart/read scope and a valid customer authentication token.
  """
  customerCart(customerToken: String!): Cart!

  """
  The cart for an anonymous user. Will create a blank cart if one does not exist, never returns null.
              
  Requires the publiccart/read scope.
  """
  deviceCart(deviceId: String!): Cart!

  """Returns the health of the service"""
  health: String

  """
  List Navs.
              
  Requires the publicnav/read permission.
  """
  navs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int
    href: String
    hrefPrefix: String

    """Returns the last n elements from the list."""
    last: Int
    linkSlug: String
    linkType: String
    navIds: [ID]
    navLevel: Int
    navType: String
  ): PublicNavConnection!

  """
  Get a page by its slug.
  
  Requires the publicpage/read scope.
  """
  page(slug: String!): PublicPage

  """
  Term aggregations for Pages, typically used to suggest terms to use in Search Filters.
  """
  pageTermAggregations(
    """The number of aggregations to return for each type."""
    numberOfResults: Int!
  ): PageTermAggregations

  """
  List pages for a Storefront with optional filters.
              
  Requires the publicpage/read scope.
  """
  pages(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Filter Pages using author"""
    author: StringFilterInput

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Filter Pages using pageType"""
    pageType: StringFilterInput

    """
    Query pages for certain terms. Searches several fields, including
    page.author, page.description, page.subtitle, page.title, pageTags, and the
    actual content of the page.
    """
    query: String

    """Filter Pages using slugs"""
    slugs: [String]

    """Sort Pages by a series of fields and directions."""
    sortOrder: [PageSortInput]

    """Filter Pages using Tags."""
    tags: [StringFilterInput]
  ): PublicPageConnectionWithSearch!

  """
  Get a product by its slug.
  
  Requires the publicproduct/read scope.
  """
  product(slug: String!): PublicProduct

  """
  Term aggregations for Products, typically used to suggest terms to use in Search Filters.
  """
  productTermAggregations(
    """The number of aggregations to return for each type."""
    numberOfResults: Int!
  ): ProductTermAggregations

  """
  Paginate through products.
  
  Requires the publicproduct/read scope.
  """
  products(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int

    """Optionally filter by manufacturer."""
    manufacturer: [StringFilterInput]

    """Optionally filter by msrp."""
    msrp: FloatRangeFilterInput

    """Optionally filter by price."""
    price: FloatRangeFilterInput

    """
    Query products for certain terms. Searches several fields, including
    product.tags, product.title, product.vendor, productLocales.description,
    productLocales.featureBullets, variant.barcode, variant.mpn, variant.sku
    """
    query: String

    """Filter Products using slugs"""
    slugs: [String]

    """
    Sort Products by a series of fields and directions, defaults to CREATED_AT/ASC.
    """
    sortOrder: [ProductSortInput]

    """Optionally filter by standardized color."""
    standardizedColor: [ProductStandardizedColorFilterInput]

    """Optionally filter by tags."""
    tags: [StringFilterInput]

    """Optionally filter by vendor."""
    vendor: StringFilterInput
  ): PublicProductConnectionWithSearch!

  """
  Get the storefront associated with the requesting storefront identity.
              
  Requires the "publicstorefront/read" permission.
  """
  storefront: PublicStorefront
}

"""
Used throughout the app to indicate what language and locality a given text is in
"""
enum ResonanceLocaleType {
  EN_US
}

"""
This is an item being saved for later, waiting for a future purchase day.
"""
type SavedForLaterItem {
  position: Int

  """
  The variant that this saved for later item is associated with.
              
  Requires publicvariant/read permission on the requesting identity.
  """
  variant: PublicVariant
  variantId: ID!
}

"""This input type is used to add or update items in savedForLater."""
input SavedForLaterItemInput {
  position: Int
  variantId: ID!
}

"""Indicates which direction to sort, defaults to ASC"""
enum SortDirection {
  ASC
  DESC
}

"""Filter using a combination of operator and an array of string values"""
input StringFilterInput {
  operator: FilterOperator
  values: [String!]!
}

"""
Indicates the key of the term aggregation, and approximately how many documents it occurs in. 
"""
type TermAggregation {
  docCount: Int!
  key: String!
}

"""Metric or Standard Dimension?"""
enum VariantShippingDimensionUnit {
  CM
  IN
}

"""Object to indicate all three shipping box dimensions and a unit"""
type VariantShippingDimensions {
  height: Float!
  length: Float!
  unit: VariantShippingDimensionUnit!
  width: Float!
}

"""Indicates a standardized color for a variant, i.e. Blue for 'Topaz'"""
enum VariantStandardizedColor {
  BEIGE
  BLACK
  BLUE
  BRONZE
  BROWN
  CLEAR
  GOLD
  GRAY
  GREEN
  MULTICOLOR
  OFFWHITE
  ORANGE
  PINK
  PURPLE
  RED
  SILVER
  WHITE
  YELLOW
}

"""Object to indicate both amount and unit of weight."""
type VariantWeight {
  amount: Float!
  unit: VariantWeightUnit!
}

"""Metric or Standard Weight?"""
enum VariantWeightUnit {
  GRAMS
  LBS
}
